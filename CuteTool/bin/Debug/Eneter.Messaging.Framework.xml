<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Eneter.Messaging.Framework</name>
    </assembly>
    <members>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.NamespaceDoc">
            <summary>
            Multiplying and forwarding of received messages. 
            </summary>
            <remarks>
            Receives messages and forwards them to all attached receivers.
            The message is then processed by more services in parallel.
            E.g. If a client needs to evaluate results from more different services.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider">
            <summary>
            The interface declares the default functionality to send and receive messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.SendMessage(System.String,System.Object)">
            <summary>
            Sends the message to desired receiver.
            </summary>
            <param name="receiverId"></param>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.RegisterMessageHandler(System.String,System.Action{System.Object})">
            <summary>
            Registers the method handling the message.
            </summary>
            <param name="receiverId"></param>
            <param name="messageHandler"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.UnregisterMessageHandler(System.String)">
            <summary>
            Unregisters the handler.
            </summary>
            <param name="receiverId"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType">
            <summary>
            Type of the message (if it is ping or a data message).
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType.Ping">
            <summary>
            Indicates, it is the ping message or ping response.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType.Message">
            <summary>
            Indicates, it is a message or a response message containing data. 
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage">
            <summary>
            The message internally used to monitor the connection and also to transfer message data.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.#ctor">
            <summary>
            Constructs the message. This constructor is used by the Xml serializer for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.#ctor(Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType,System.Object)">
            <summary>
            Constructs the message from specified parameters.
            </summary>
            <param name="messageType">type of the message, ping or regular message</param>
            <param name="messageContent">message content, in case of ping this parameter is not used</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.MessageType">
            <summary>
            Type of the message. Ping or regular message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.MessageContent">
            <summary>
            Message. In case of the 'ping', this property is null.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.NamespaceDoc">
            <summary>
            Extension providing buffering of sent messages for cases the connection is not available.
            </summary>
            <remarks>
            The buffered messaging is intended to temporarily store sent messages until the network connection is established.<br/>
            Typical scenarios are:
            <br/><br/>
            <b>Short disconnections</b><br/>
            In case of unstable the network the connection can broken. Buffered messaging will try to reconnect the broken connection
            and meanwhile it will store sent messages in the buffer. Then when the connection is repaired it will send messages from
            the buffer.
            <br/><br/>
            <b>Independent startup order</b><br/>
            It can be tricky to start communicating application in a defined order. Buffered messaging allows to start
            applications in undefined order. If messages are sent to an application which is not started yet they will be stored
            in the buffer until the application is started.
            
            
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.VoidMessage">
            <summary>
            Represents an empty data type 'void'.
            Can be used if no type is expected as a message.
            </summary>
            <remarks>
            <example>
            The following example shows how to use VoidMessage to declare a message sender
            sending string messages and receiving "nothing".
            <code>
            ...
            IDuplexTypedMessageSender&lt;VoidMessage, string&gt; myMessageSender;
            ...
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1">
            <summary>
            Event argument used when the typed message is received.
            </summary>
            <typeparam name="_RequestMessageType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.#ctor(System.String,System.String,`0)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseReceiverId">identifies the client where the response can be sent</param>
            <param name="senderAddress">address of the message sender. It is null if not applicable for the messaging system.</param>
            <param name="requestMessage">message</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Constructs the message from the exception.
            </summary>
            <param name="responseReceiverId">identifies the client where the response can be sent</param>
            <param name="senderAddress">address of the message sender. It is null if not applicable for the messaging system.</param>
            <param name="error">error detected during receiving the message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.RequestMessage">
            <summary>
            Returns the received message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.ResponseReceiverId">
            <summary>
            Returns the client identifier where the response can be sent.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.SenderAddress">
            <summary>
            Returns the address where the sender of the request message is located. (e.g. IP address of the client).
            It can be empty string if not applicable for used messaging.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessagesFactory">
            <summary>
            Creates reliable sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessagesFactory.CreateReliableDuplexTypedMessageSender``2">
            <summary>
            Creates reliable typed message sender.
            </summary>
            <typeparam name="_ResponseType">type of response messages</typeparam>
            <typeparam name="_RequestType">type of request messages</typeparam>
            <returns>reliable typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessagesFactory.CreateReliableDuplexTypedMessageReceiver``2">
            <summary>
            Creates reliable typed message receiver.
            </summary>
            <typeparam name="_ResponseType">type of response messages</typeparam>
            <typeparam name="_RequestType">type of request messages</typeparam>
            <returns>reliable typed message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IInputConnector">
            <summary>
            Declares the input connector which provides a basic low-level listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IInputConnector.StartListening(System.Func{Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.MessageContext,System.Boolean})">
            <summary>
            Starts listening to messages.
            </summary>
            <param name="messageHandler">handler processing incoming messages. If it returns true the connection stays
            open and listener can loop for a next messages. If it returns false the listener shall not loop for the
            next message.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IInputConnector.StopListening">
            <summary>
            Stops listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IInputConnector.CreateResponseSender(System.String)">
            <summary>
            In case the response receiver address comes inside the message
            the duplex input channel calls this method to get the response receiver.
            </summary>
            <param name="responseReceiverAddress"></param>
            <returns></returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IInputConnector.IsListening">
            <summary>
            Returns true if the listening is running.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.ISender">
            <summary>
            Declares the low-level sender of request messages and response messages.
            </summary>
            <remarks>
            IOutputConnector is derived from ISender so that it can send messages.
            IInputConnector uses ISender to send back response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.ISender.SendMessage(System.Object)">
            <summary>
            Sends a message NOT using the stream. This method does not have to be implemented if IsStreamWritter returns false.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.ISender.SendMessage(System.Action{System.IO.Stream})">
            <summary>
            Sends a message using the stream. This method does not have to be implemented if IsStreamWritter returns true.
            </summary>
            <param name="toStreamWritter"></param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.ISender.IsStreamWritter">
            <summary>
            If it returns true then SendMessage(Action&lt;Stream&gt; toStreamWritter) will be used to send messages.
            </summary>
            <remarks>
            The point is that sometimes are messages sent using a stream and sometimes not. If this property
            returns true then the implementation of the sender expects messages are sent using the stream.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory">
            <summary>
            Messaging system delivering messages via websockets.
            </summary>
            <remarks>
            It creates the communication channels using WebSockets for sending and receiving messages.
            The channel id must be a valid URI address. E.g.: ws://127.0.0.1:6080/MyService/. <br/>
            Notice, Silverlight and Windows Phone do not support TCP listeners and therefore WebSocket listeners are not suported too.
            Therefore, only sending messages (and receiving response messages) is possible on these platforms.<br/>
            More details:<br/>
            TCP in Silverlight is restricted to ports 4502 - 4532 and requires the TcpPolicyServer running on the service side.<br/>
            Windows Phone 7.0 does not suport TCP at all. The TCP is supported from Windows Phone 7.1. TCP in Windows Phone 7.1
            does not require TcpPolicyServer and is not restricted to certain ports as in Silverlight. 
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory">
            <summary>
            Messaging factory to create output and input channels.
            </summary>
            <remarks>
            This factory interface is supposed to be implemented by all messaging systems.
            Particular messaging systems are then supposed to provide correct implementations for output and input channels
            using their transportation mechanisms. E.g. for TCP, Websockets, ... . 
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel that sends messages to the duplex input channel and receives response messages.
            </summary>
            <param name="channelId">id representing receiving input channel address.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel that sends messages to the duplex input channel and receives response messages.
            </summary>
            <param name="channelId">id representing receiving input channel address.</param>
            <param name="responseReceiverId">unique identifier of the response receiver represented by this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel that receives messages from the duplex output channel and sends back response messages.
            </summary>
            <param name="channelId">id representing the input channel address.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.#ctor">
            <summary>
            Constructs the WebSocket messaging factory.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the WebSocket messaging factory.
            </summary>
            <param name="protocolFormatter">formatter used for low-level messaging between output and input channels.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using WebSocket.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid URI address e.g. ws://127.0.0.1:8090/MyService/ </param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using WebSocket.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid URI address e.g. ws://127.0.0.1:8090/ </param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using WebSocket.
            The method is not supported in Silverlight and Windows Phone.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">Identifies this duplex input channel. The channel id must be a valid URI address (e.g. ws://127.0.0.1:8090/MyService/) the input channel will listen to.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.ServerSecurityStreamFactory">
            <summary>
            Sets or gets the security stream factory for the server.
            If the factory is set, then the input channel and the duplex input channel use it to establish
            the secure communication.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.ClientSecurityStreamFactory">
            <summary>
            Sets and gets the security stream factory for the client.
            If the factory is set, then the output channel and the duplex output channel use it to establish
            the secure communication.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.ConnectTimeout">
            <summary>
            Sets ot gets timeout to open the connection. Default is 30000 miliseconds. Value 0 is infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.SendTimeout">
            <summary>
            Sets or gets timeout to send a message. Default is 0 what it infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.ReceiveTimeout">
            <summary>
            Sets or gets timeout to receive a message. If not received within the time the connection is closed. Default is 0 what it infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.InputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex input channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed by one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IOutputConnector">
            <summary>
            Declares the output connector which provides a basic low-level functionality to open connection and send messages.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.NamespaceDoc">
            <summary>
            Helper to queue and process messages with a working thread.
            </summary>
            <remarks>
            Several threads can put messages to the queue and one thread removes them and calls a call-back method to process them.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel">
            <summary>
            Duplex output channel that can send messages to the duplex input channel and receive response messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.SendMessage(System.Object)">
            <summary>
            Sends the message to the duplex input channel.
            </summary>
            <remarks>
            Notice, there is a limitation for the Silverlight platform using HTTP.
            If the message is sent via HTTP from the main Silverlight thread, then in case of a failure, the exception is not thrown.
            Therefore, it is recommended to execute this method in a different thread.
            </remarks>
            <exception cref="T:System.InvalidOperationException">If the connection is not open.</exception>
            <exception cref="T:System.Exception">Any exception thrown during sending of a message. E.g. if sending via TCP fails.</exception>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.OpenConnection">
            <summary>
            Opens the connection with the duplex input channel.
            </summary>
            <remarks>
            Notice, there is a limitation for the Silverlight platform using HTTP.
            If the message is sent via HTTP from the main Silverlight thread, then in case of a failure, the exception is not thrown.
            Therefore, it is recommended to execute this method in a different thread.
            </remarks>
            <exception cref="T:System.InvalidOperationException">If the connection is already open.</exception>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.CloseConnection">
            <summary>
            Closes the connection with the duplex input channel.
            </summary>
            <remarks>
            Notice, there is a limitation for the Silverlight platform.
            If this method is executed in the main Silverlight thread, then in case of a failure the exception will not be propagated.
            It is recommended to execute this method in a different thread.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionOpened">
            <summary>
            The event is invoked when the connection with the duplex input channel was opened.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed">
            <summary>
            The event is invoked when the connection with the duplex input channel was closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ResponseMessageReceived">
            <summary>
            The event is invoked when a response message was received.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ChannelId">
            <summary>
            Returns the id of the duplex input channel where messages are sent.
            It represents the address where messages are sent.
            </summary>
            <remarks>
            The channel id represents the communication address. The syntax of the channel id depends on the chosen
            communication. If the messaging is based on http, the address would be e.g.: http://127.0.0.1/Something/ or
            http://127.0.0.1:7345/Something/. If the communication is based on tcp, the address would be e.g.: tcp://127.0.0.1:7435/.
            For the named pipe, e.g. net.pipe://127.0.0.1/SomePipeName/.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ResponseReceiverId">
            <summary>
            Returns response receiving id of the duplex output channel.
            </summary>
            <remarks>
            The response receiver id is a unique identifier used by the duplex input channel to recognize
            connected duplex output channels.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.IsConnected">
            <summary>
            Returns true if the duplex output channel is connected to the duplex input channel and listens to response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.Dispatcher">
            <summary>
            Returns dispatcher that defines the threading model for raising events.
            </summary>
            <remarks>
            Dispatcher is responsible for raising ConnectionOpened, ConnectionClosed and ResponseMessageReceived events
            according to desired thread model.
            E.g. events are queued and raised by one particular thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory">
            <summary>
            Factory to create typed message senders and receivers.
            </summary>
            <remarks>
            The following example shows how to send a receive messages:
            <example>
            Implementation of receiver:
            <code>
            using System;
            using Eneter.Messaging.EndPoints.TypedMessages;
            using Eneter.Messaging.MessagingSystems.MessagingSystemBase;
            using Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem;
            
            namespace CalculatorService
            {
                // Request message.
                public class RequestMessage
                {
                    public int Number1 { get; set; }
                    public int Number2 { get; set; }
                }
            
                // Response message.
                public class ResponseMessage
                {
                    public int Result { get; set; }
                }
            
                class Program
                {
                    static void Main(string[] args)
                    {
                        // Create message receiver.
                        IDuplexTypedMessagesFactory aReceiverFactory = new DuplexTypedMessagesFactory();
                        IDuplexTypedMessageReceiver&lt;ResponseMessage, RequestMessage&gt; aReceiver =
                            aReceiverFactory.CreateDuplexTypedMessageReceiver&lt;ResponseMessage, RequestMessage&gt;();
            
                        // Subscribe to process request messages.
                        aReceiver.MessageReceived += OnMessageReceived;
            
                        // Use WebSocket for the communication.
                        // Note: You can also other messagings. E.g. TcpMessagingSystemFactory
                        IMessagingSystemFactory aMessaging = new WebSocketMessagingSystemFactory();
                        IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("ws://192.168.1.102:8099/aaa/");
            
                        // Attach the input channel to the receiver and start listening.
                        aReceiver.AttachDuplexInputChannel(anInputChannel);
            
                        Console.WriteLine("The calculator service is running. Press ENTER to stop.");
                        Console.ReadLine();
            
                        // Detach the input channel to stop listening.
                        aReceiver.DetachDuplexInputChannel();
                    }
            
                    private static void OnMessageReceived(object sender, TypedRequestReceivedEventArgs&lt;RequestMessage&gt; e)
                    {
                        // Calculate numbers.
                        ResponseMessage aResponseMessage = new ResponseMessage();
                        aResponseMessage.Result = e.RequestMessage.Number1 + e.RequestMessage.Number2;
            
                        Console.WriteLine("{0} + {1} = {2}", e.RequestMessage.Number1, e.RequestMessage.Number2, aResponseMessage.Result);
            
                        // Send back the response message.
                        var aReceiver = (IDuplexTypedMessageReceiver&lt;ResponseMessage, RequestMessage&gt;)sender;
                        aReceiver.SendResponseMessage(e.ResponseReceiverId, aResponseMessage);
                    }
                }
            }
            
            </code>
            </example>
            <example>
            Implementation of sender:
            <code>
            using System;
            using System.Windows.Forms;
            using Eneter.Messaging.EndPoints.TypedMessages;
            using Eneter.Messaging.MessagingSystems.MessagingSystemBase;
            using Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem;
            
            namespace CalculatorClient
            {
                public partial class Form1 : Form
                {
                    // Request message.
                    public class RequestMessage
                    {
                        public int Number1 { get; set; }
                        public int Number2 { get; set; }
                    }
            
                    // Response message.
                    public class ResponseMessage
                    {
                        public int Result { get; set; }
                    }
            
                    private IDuplexTypedMessageSender&lt;ResponseMessage, RequestMessage&gt; mySender;
            
                    public Form1()
                    {
                        InitializeComponent();
            
                        OpenConnection();
                    }
            
                    private void Form1_FormClosed(object sender, FormClosedEventArgs e)
                    {
                        CloseConnection();
                    }
            
            
                    private void OpenConnection()
                    {
                        // Create the message sender.
                        IDuplexTypedMessagesFactory aSenderFactory = new DuplexTypedMessagesFactory();
                        mySender = aSenderFactory.CreateDuplexTypedMessageSender&lt;ResponseMessage, RequestMessage&gt;();
            
                        // Subscribe to receive response messages.
                        mySender.ResponseReceived += OnResponseReceived;
            
                        // Use Websocket for the communication.
                        // If you want to use TCP then use TcpMessagingSystemFactory().
                        IMessagingSystemFactory aMessaging = new WebSocketMessagingSystemFactory();
                        IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("ws://192.168.1.102:8099/aaa/");
            
                        // Attach the output channel and be able to send messages
                        // and receive response messages.
                        mySender.AttachDuplexOutputChannel(anOutputChannel);
                    }
            
                    private void CloseConnection()
                    {
                        // Detach input channel and stop listening to response messages.
                        mySender.DetachDuplexOutputChannel();
                    }
            
                    private void CalculateBtn_Click(object sender, EventArgs e)
                    {
                        // Create the request message.
                        RequestMessage aRequest = new RequestMessage();
                        aRequest.Number1 = int.Parse(Number1TextBox.Text);
                        aRequest.Number2 = int.Parse(Number2TextBox.Text);
            
                        // Send request to the service to calculate 2 numbers.
                        mySender.SendRequestMessage(aRequest);
                    }
            
                    private void OnResponseReceived(object sender, TypedResponseReceivedEventArgs&lt;ResponseMessage&gt; e)
                    {
                        // Display the result using the UI thread.
                        UI(() =&gt; ResultTextBox.Text = e.ResponseMessage.Result.ToString());
                    }
            
                    // Helper method to invoke a delegate in the UI thread.
                    // Note: You can manipulate UI controls only from the UI tread.
                    private void UI(Action action)
                    {
                        if (InvokeRequired)
                        {
                            Invoke(action);
                        }
                        else
                        {
                            action();
                        }
                    }
                }
            }
            </code>
            </example>
            <example>
            Implementation of synchronous sender (after sending it waits for the response):
            <code>
            using System;
            using System.Windows.Forms;
            using Eneter.Messaging.EndPoints.TypedMessages;
            using Eneter.Messaging.MessagingSystems.MessagingSystemBase;
            using Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem;
            
            namespace CalculatorClientSync
            {
                public partial class Form1 : Form
                {
                    // Request message.
                    public class RequestMessage
                    {
                        public int Number1 { get; set; }
                        public int Number2 { get; set; }
                    }
            
                    // Response message.
                    public class ResponseMessage
                    {
                        public int Result { get; set; }
                    }
            
                    private ISyncDuplexTypedMessageSender&lt;ResponseMessage, RequestMessage&gt; mySender;
            
                    public Form1()
                    {
                        InitializeComponent();
            
                        OpenConnection();
                    }
            
                    private void Form1_FormClosed(object sender, FormClosedEventArgs e)
                    {
                        CloseConnection();
                    }
            
                    private void OpenConnection()
                    {
                        // Create the message sender.
                        IDuplexTypedMessagesFactory aSenderFactory = new DuplexTypedMessagesFactory();
                        mySender = aSenderFactory.CreateSyncDuplexTypedMessageSender&lt;ResponseMessage, RequestMessage&gt;();
            
                        // Use Websocket for the communication.
                        // If you want to use TCP then use TcpMessagingSystemFactory().
                        IMessagingSystemFactory aMessaging = new WebSocketMessagingSystemFactory();
                        IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("ws://192.168.1.102:8099/aaa/");
            
                        // Attach the output channel and be able to send messages
                        // and receive response messages.
                        mySender.AttachDuplexOutputChannel(anOutputChannel);
                    }
            
                    private void CloseConnection()
                    {
                        // Detach input channel and stop listening to response messages.
                        mySender.DetachDuplexOutputChannel();
                    }
            
                    private void CalculateBtn_Click(object sender, EventArgs e)
                    {
                        // Create the request message.
                        RequestMessage aRequest = new RequestMessage();
                        aRequest.Number1 = int.Parse(Number1TextBox.Text);
                        aRequest.Number2 = int.Parse(Number2TextBox.Text);
            
                        // Send request to the service to calculate 2 numbers.
                        ResponseMessage aResponse = mySender.SendRequestMessage(aRequest);
            
                        // Display the result.
                        ResultTextBox.Text = aResponse.Result.ToString();
                    }
                }
            }
            </code>
            </example>
            
            
            
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory">
            <summary>
            Creates senders and receivers of typed messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory.CreateDuplexTypedMessageSender``2">
            <summary>
            Creates duplex typed message sender that can send request messages and receive response messages of specified type.
            </summary>
            <typeparam name="TResponse">Type of response messages.</typeparam>
            <typeparam name="TRequest">Type of request messages.</typeparam>
            <returns>duplex typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory.CreateSyncDuplexTypedMessageSender``2">
            <summary>
            Creates synchronous duplex typed message sender that sends a request message and then
            waits until the response message is received.
            </summary>
            <typeparam name="TResponse">Response message type.</typeparam>
            <typeparam name="TRequest">Request message type.</typeparam>
            <returns>synchronous duplex typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory.CreateDuplexTypedMessageReceiver``2">
            <summary>
            Creates duplex typed message receiver that can receive request messages and
            send back response messages of specified type.
            </summary>
            <typeparam name="TResponse">Type of response messages.</typeparam>
            <typeparam name="TRequest">Type of receiving messages.</typeparam>
            <returns>duplex typed message receiver</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor">
            <summary>
            Constructs the factory with xml serializer. <br/>
            </summary>
            <remarks>
            The factory will create senders and receivers with the default XmlStringSerializer<br/>
            and the factory will create ISyncDuplexTypedMessageSender that can wait infinite
            time for the response message from the service.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with specified serializer.
            </summary>
            <remarks>
            The factory will create senders and receivers with the specified serializer
            and the factory will create ISyncDuplexTypedMessageSender that can wait infinite
            time for the response message from the service.<br/>
            <br/>
            For possible serializers you can refer to <see cref="N:Eneter.Messaging.DataProcessing.Serializing"/>
            </remarks>
            <param name="serializer">Serializer used to serialize request and response messages.</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor(System.TimeSpan)">
            <summary>
            Constructs the factory with specified timeout for ISyncDuplexTypedMessageSender.
            </summary>
            <remarks>
            The factory will create senders and receivers using the default XmlStringSerializer
            and the factory will create ISyncDuplexTypedMessageSender with specified timeout
            indicating how long it can wait for a response message from the service.
            </remarks>
            <param name="syncResponseReceiveTimeout">maximum waiting time when synchronous message sender is used.</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor(System.TimeSpan,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with specified timeout for synchronous message sender and specified serializer.
            </summary>
            <param name="syncResponseReceiveTimeout">maximum waiting time when synchronous message sender is used.</param>
            <param name="serializer">serializer that will be used to serialize/deserialize messages.</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.CreateDuplexTypedMessageSender``2">
            <summary>
            Creates duplex typed message sender that can send request messages and receive response
            messages of specified type.
            </summary>
            <typeparam name="_ResponseType">Type of response messages.</typeparam>
            <typeparam name="_RequestType">Type of request messages.</typeparam>
            <returns>duplex typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.CreateSyncDuplexTypedMessageSender``2">
            <summary>
            Creates synchronous duplex typed message sender that sends a request message and then
            waits until the response message is received.
            </summary>
            <typeparam name="_ResponseType">Response message type.</typeparam>
            <typeparam name="_RequestType">Request message type.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.CreateDuplexTypedMessageReceiver``2">
            <summary>
            Creates duplex typed message receiver that can receive request messages and
            send back response messages of specified type.
            </summary>
            <typeparam name="_ResponseType">Type of response messages.</typeparam>
            <typeparam name="_RequestType">Type of receiving messages.</typeparam>
            <returns>duplex typed message receiver</returns>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.SyncDuplexTypedSenderThreadMode">
            <summary>
            Gets or sets the threading mode for receiving ConnectionOpened and ConnectionClosed events for SyncDuplexTypedMessageSender.
            </summary>
            <remarks>
            E.g. you use SyncDuplexTypedMessageSender and you want to route ConnectionOpened and ConnectionClosed events
            to the main UI thread of your WPF based application. Therefore you specify WindowsDispatching when you create your
            TCP duplex output channel which you then attach to the SyncDuplexTypedMessageSender.<br/>
            Later when the application is running you call SyncDuplexTypedMessageSender.SendRequestMessage(..).<br/>
            However if you call it from the main UI thread the deadlock occurs.
            Because this component is synchronous the SendRequestMessage(..) will stop the calling main UI thread and will wait
            for the response. But the problem is when the response comes the underlying TCP messaging will try to route it to
            the main UI thread (as was specified during creating TCP duplex output channel).<br/>
            But because the main UI thread is suspending and waiting the message will never arrive.<br/>
            <br/>
            Solution:<br/>
            Do not specify the threading mode when you create yur duplex output channel but specify it using the
            SyncDuplexTypedSenderThreadMode property when you create SyncDuplexTypedMessageSender.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.ErrorHandler">
            <summary>
            Internal helper class to trace typical messags.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient">
            <summary>
            WebSocket client.
            </summary>
            <remarks>
            Represents the client for the websocket communication.
            <example>
            The following example shows how to communicate with a websocket server.
            <code>
            WebSocketClient aClient = new WebSocketClient("ws://127.0.0.1:8045/MyService/");
            
            // Subscribe to receive messages.
            aClient.MessageReceived += OnResponseMessageReceived;
            
            // Open the connection.
            aClient.OpenConnection();
            
            // Send a text message.
            aClient.SendMessage("Hello.");
            
            ....
            
            // Handler of response messages.
            void OnResponseMessageReceived(object sender, WebSocketMessage e)
            {
                // Read the whole text message.
                if (e.IsText)
                {
                    string aMessage = e.GetWholeTextMessage();
                    ...
                }
            }
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.#ctor(System.Uri)">
            <summary>
            Constructs the websocket client.
            </summary>
            <param name="uri">websocket uri address. Provide port number too. e.g. ws://127.0.0.1:8055/myservice/<br/>
            You can also specify the query that can be used to pass some open connection related parameters.
            e.g. ws://127.0.0.1:8055/myservice/?param1=10&amp;param2=20
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.#ctor(System.Uri,Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ISecurityFactory)">
            <summary>
            Constructs the websocket client.
            </summary>
            <param name="uri">websocket uri address. Provide port number too. e.g. ws://127.0.0.1:8055/myservice/<br/>
            You can also specify the query that can be used to pass some open connection related parameters.
            e.g. ws://127.0.0.1:8055/myservice/?param1=10&amp;param2=20
            </param>
            <param name="clientSecurityFactory">
            Factory allowing SSL communication. <see cref="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory"/>
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.OpenConnection">
            <summary>
            Opens connection to the websocket server.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.CloseConnection">
            <summary>
            Closes connection with the webscocket server.
            </summary>
            <remarks>
            It sends the close message to the service and closes the underlying tcp connection.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.SendMessage(System.Object)">
            <summary>
            Sends message to the server.
            </summary>
            <remarks>
            The message must be type of string or byte[].
            If the type is string then the message is sent as the text message via text frame.
            If the type is byte[] the message is sent as the binary message via binary frame.
            </remarks>
            <param name="data">message to be sent. Must be byte[] or string.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.SendMessage(System.Object,System.Boolean)">
            <summary>
            Sends message to the server. Allows to send the message via multiple frames.
            </summary>
            <remarks>
            The message must be type of string or byte[].
            If the type is string then the message is sent as the text message via text frame.
            If the type is byte[] the message is sent as the binary message via binary frame.<br/>
            <br/>
            It allows to send the message in multiple frames. The server then can receive all parts separately
            using WebSocketMessage.InputStream or as a whole message using WebSocketMessage.GetWholeMessage().
            <example>
            The following example shows how to send 'Hello world.' in three parts.
            <code>
                ...
                
                // Send the first part of the message.
                client.SendMessage("Hello ", false);
                
                // Send the second part.
                client.SendMessage("wo", false);
                
                // Send the third final part.
                client.SendMessage("rld.", true);
                
                ...
            </code>
            </example>
            </remarks>
            <param name="data"></param>
            <param name="isFinal"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.SendPing">
            <summary>
            Pings the service. According to websocket protocol, pong should be responded.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.SendPong">
            <summary>
            Sends unsolicited pong to the service.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.ConnectionOpened">
            <summary>
            Event is invoked when the connection is open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.ConnectionClosed">
            <summary>
            Event is invoked when the connection is closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.PongReceived">
            <summary>
            Event is invoked when the pong is received. E.g. when the server responded ping.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.MessageReceived">
            <summary>
            The event is invoked when a data message from server is received.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.ConnectTimeout">
            <summary>
            Sets or gets the connection timeout in miliseconds. Default value is 30000 miliseconds.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.SendTimeout">
            <summary>
            Sets or gets the send timeout in miliseconds. Default value is 30000 miliseconds.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.ReceiveTimeout">
            <summary>
            Sets or gets the receive timeout in miliseconds. If exceeded the connection is closed. Default value is -1 infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.Uri">
            <summary>
            Returns address of websocket server.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.HeaderFields">
            <summary>
            Allows to get and set header-fields which shall be sent in open connection request.
            </summary>
            <remarks>
            It allows to add your custom header fields that shell be sent in the open connection request.
            The header-field Sec-WebSocket-Key is generated and added when OpenConnection() is called.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.IsConnected">
            <summary>
            Returns true if the connection to the server is open.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketClient.LocalEndPoint">
            <summary>
            Returns the IP address of the client used for the communication with the server.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext">
            <summary>
            Represents the client context on the server side.
            </summary>
            <remarks>
            The client context is obtained when a client opened the connection with the server and
            it provides functionality to receive messages from the client and send back response messages.
            <br/>
            To see the example refer to <see cref="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener"/>.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.SendMessage(System.Object)">
            <summary>
            Sends message to the client.
            </summary>
            <remarks>
            The message must be type of string or byte[]. If the type is string then the message is sent as the text message via text frame.
            If the type is byte[] the message is sent as the binary message via binary frame.
            </remarks>
            <param name="data">message to be sent to the client. Must be byte[] or string.</param>
            <exception cref="T:System.ArgumentException">input parameter is not string or byte[].</exception>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.SendMessage(System.Object,System.Boolean)">
            <summary>
            Sends message to the client. Allows to send the message via multiple frames.
            </summary>
            <remarks>
            The message must be type of string or byte[]. If the type is string then the message is sent as the text message via text frame.
            If the type is byte[] the message is sent as the binary message via binary frame.<br/>
            <br/>
            It allows to send the message in multiple frames. The client then can receive all parts separately
                
            <example>
            The following example shows how to send 'Hello world.' in three parts.
            <code>
            void ProcessConnection(IWebSocketClientContext clientContext)
            {
                ...
                
                // Send the first part of the message.
                clientContext.SendMessage("Hello ", false);
                
                // Send the second part.
                clientContext.SendMessage("wo", false);
                
                // Send the third final part.
                clientContext.SendMessage("rld.", true);
                
                ...
            }
            </code>
            </example>
            </remarks>
            <param name="data">message to be sent to the client. The message can be byte[] or string.</param>
            <param name="isFinal">true if this is the last part of the message.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.ReceiveMessage">
            <summary>
            Waits until a message is received from the client.
            </summary>
            <remarks>
            <example>
            Example shows how to implement a loop receiving the text messages from the client.
            <code>
            void ProcessConnection(IWebSocketClientContext clientContext)
            {
                // The loop waiting for incoming messages.
                // Note: The waiting thread is released when the connection is closed.
                WebSocketMessage aWebSocketMessage;
                while ((aWebSocketMessage = clientContext.ReceiveMessage()) != null)
                {
                    if (aWebSocketMessage.IsText)
                    {
                        // Wait until all data frames are collected
                        // and return the message.
                        string aMessage = aWebSocketMessage.GetWholeTextMessage();
                        ...
                    }
                }
            }
            </code>
            </example>
            </remarks>
            <returns>message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.SendPing">
            <summary>
            Pings the client. According to websocket protocol, pong should be responded.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.SendPong">
            <summary>
            Sends unsolicited pong to the client.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.CloseConnection">
            <summary>
            Closes connection with the client.
            </summary>
            <remarks>
            It sends the close message to the client and closes the underlying tcp connection.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.ConnectionClosed">
            <summary>
            The event is invoked when the connection with the client was closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.PongReceived">
            <summary>
            The event is invoked when the pong message was received.
            </summary>
            <remarks>
            The pong message is sent as a response to ping. According to websocket protocol
            unsolicit pong can be sent too. (i.e. it does not have to be a response to a ping)<br/>
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.ClientEndPoint">
            <summary>
            Returns the IP address of the connected client.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.IsConnected">
            <summary>
            Returns true if the client is connected.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.Uri">
            <summary>
            Returns URI of this connection including query parameters sent from by the client.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.HeaderFields">
            <summary>
            Returns the readonly dictionary containing header HTTP header fields.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.SendTimeout">
            <summary>
            Sets or gets the send timeout in miliseconds. Default value is 0 what is infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext.ReceiveTimeout">
            <summary>
            Sets or gets the receive timeout in miliseconds. Default value is 0 what is infinite time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.IHostListenerFactory">
            <summary>
            Instantiates the host listener for the given IP address and port.
            </summary>
            <remarks>
            The host listener then processes the TCP connection and parses out the path.
            Then it forwards the message to the correct path listener.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.IHostListenerFactory.CreateHostListener(System.Net.IPEndPoint,Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ISecurityFactory)">
            <summary>
            Creates the host listener.
            </summary>
            <param name="address"></param>
            <param name="securityFactory"></param>
            <returns></returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.IHostListenerFactory.ListenerType">
            <summary>
            Returns the type of the of the host listener. The host listener is derived from HostListenerBase.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transferring messages via shared memory. (Faster than Named Pipes.)
            </summary>
            <remarks>
            It transfers messages between processes running on the same machine using shared memory.
            Transferring messages via the shared memory is faster than using Named Pipes.<br/>
            Messaging via the shared memeory is supported only in .Net 4.0 or higher.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory">
            <summary>
            Factory creating duplex output channels for the communication with Android device via the USB cable.
            </summary>
            <remarks>
            When Android device is connected to the computer via the USB cable the process adb (Android Debug Bridge) is started
            on the computer and adbd (Android Debug Bridge Daemon) is started on the Android device.
            These processes then communicate via the USB cable.<br/>
            <br/>
            How this messaging works:
            <ol>
            <li>Your desktop application sends a message via the output channel created by AndroidUsbCableMessagingFactory</li>
            <li>The output channel internally sends the message via TCP to the adb service.</li>
            <li>adb service receives data and transfers it via USB cable to adbd.</li>
            <li>adbd in the Android device receives data and forwards it via TCP to the desired port.</li>
            <li>Android application listening on that port receives the message and processes it.</li>
            </ol>
            Notice there is a restrction for this type of communication:<br/>
            The Android application must be a listener (service) and the computer application must be the client.<br/>
            </remarks>
            <example>
            The service on the android side. (implemented in Java)
            <code>
            package eneter.testing;
            
            import eneter.messaging.diagnostic.EneterTrace;
            import eneter.messaging.endpoints.typedmessages.*;
            import eneter.messaging.messagingsystems.messagingsystembase.*;
            import eneter.messaging.messagingsystems.tcpmessagingsystem.TcpMessagingSystemFactory;
            import eneter.net.system.EventHandler;
            import android.app.Activity;
            import android.os.Bundle;
            
            public class AndroidUsbCableServiceActivity extends Activity
            {
                // Eneter communication.
                private IDuplexTypedMessageReceiver&lt;String, String&gt; myEchoReceiver;
                
                
                /** Called when the activity is first created. */
                @Override
                public void onCreate(Bundle savedInstanceState)
                {
                    super.onCreate(savedInstanceState);
                    setContentView(R.layout.main);
                    
                    // Start listening.
                    startListening();
                }
                
                @Override
                public void onDestroy()
                {
                    stopListening();
                    
                    super.onDestroy();
                }
                
                private void startListening()
                {
                    try
                    {
                        // Create message receiver.
                        IDuplexTypedMessagesFactory aReceiverFactory = new DuplexTypedMessagesFactory();
                        myEchoReceiver = aReceiverFactory.createDuplexTypedMessageReceiver(String.class, String.class);
                        
                        // Subscribe to receive messages.
                        myEchoReceiver.messageReceived().subscribe(new EventHandler&lt;TypedRequestReceivedEventArgs&lt;String&gt;&gt;()
                            {
                                @Override
                                public void onEvent(Object sender, TypedRequestReceivedEventArgs&lt;String&gt; e)
                                {
                                    // Response back with the same message.
                                    try
                                    {
                                        myEchoReceiver.sendResponseMessage(e.getResponseReceiverId(), e.getRequestMessage());
                                    }
                                    catch (Exception err)
                                    {
                                        EneterTrace.error("Sending echo response failed.", err);
                                    }
                                }
                            });
                        
                        // Create TCP messaging.
                        // It must listen to IP address 127.0.0.1. You can set desired port e.g. 8090.
                        IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
                        IDuplexInputChannel anInputChannel = aMessaging.createDuplexInputChannel("tcp://127.0.0.1:8090/");
                        
                        // Attach the input channel to the receiver and start listening.
                        myEchoReceiver.attachDuplexInputChannel(anInputChannel);
                    }
                    catch (Exception err)
                    {
                        EneterTrace.error("OpenConnection failed.", err);
                    }
                }
                
                private void stopListening()
                {
                    // Detach input channel and stop listening.
                    myEchoReceiver.detachDuplexInputChannel();
                }
            }
            </code>
            </example>
            
            <example>
            The client application communicating with the Android application via the USB cable.
            <code>
            using System;
            using System.Windows.Forms;
            using Eneter.Messaging.EndPoints.TypedMessages;
            using Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem;
            using Eneter.Messaging.MessagingSystems.MessagingSystemBase;
            
            namespace AndroidEchoClient
            {
                public partial class Form1 : Form
                {
                    private IDuplexTypedMessageSender&lt;string, string&gt; myEchoSender;
            
                    public Form1()
                    {
                        InitializeComponent();
            
                        // Echo sender-receiver
                        IDuplexTypedMessagesFactory aSenderFactory = new DuplexTypedMessagesFactory();
                        myEchoSender = aSenderFactory.CreateDuplexTypedMessageSender&lt;string, string&gt;();
            
                        // Subscribe to get the response.
                        myEchoSender.ResponseReceived += OnResponseReceived;
            
                        // Create messaging using the USB cable connected to Android device.
                        IMessagingSystemFactory aMessaging = new AndroidUsbCableMessagingFactory();
            
                        // Create output channel.
                        // It sets the Android application listens to port 8090.
                        IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("8090");
                        myEchoSender.AttachDuplexOutputChannel(anOutputChannel);
                    }
            
                    private void Form1_FormClosed(object sender, FormClosedEventArgs e)
                    {
                        myEchoSender.DetachDuplexOutputChannel();
                    }
            
                    private void SendBtn_Click(object sender, EventArgs e)
                    {
                        // Send the message.
                        myEchoSender.SendRequestMessage(TextMessageTextBox.Text);
                    }
            
                    private void OnResponseReceived(object sender, TypedResponseReceivedEventArgs&lt;string&gt; e)
                    {
                        // This is not the UI thread, so
                        // route displaying to the main UI thread.
                        if (InvokeRequired)
                        {
                            Action aUIUpdate = () =&gt; ResponseLabel.Text = e.ResponseMessage;
                            Invoke(aUIUpdate);
                        }
                        else
                        {
                            ResponseLabel.Text = e.ResponseMessage;
                        }
                    }
            
                }
            }
            
            </code>
            </example>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.#ctor">
            <summary>
            Constructs the Android messaging via the USB cable. It expects the adb service listens on default port 5037.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.#ctor(System.Int32,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter{System.Byte[]})">
            <summary>
            Constructs the Android messaging via the USB cable with specified parameters.
            </summary>
            <param name="adbHostPort">Port where adb service is listening to commands. Default value is 5037.</param>
            <param name="protocolFormatter">Low level formatting used for encoding messages between channels.
            EneterProtocolFormatter() can be used by default.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages via the USB cable to the duplex input channel on Android device.
            </summary>
            <remarks>
            <example>
            Using AndroidUsbCableMessagingFactory to create a client on the computer.
            <code>
            // Create messaging using Android USB cable.
            IMessagingSystemFactory aMessaging = new AndroidUsbCableMessagingFactory();
            
            // Create duplex output channel that will comunicate via the port 7634.
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("7634");
            
            // Create message sender that will send messages.
            ISyncTypedMessagesFactory aSenderFactory = new SyncTypedMessagesFactory();
            ISyncTypedMessageSender aSender = aSenderFactory.CreateSyncMessageSender&lt;string,string&gt;();
            
            // Attach the output channel and be able to send messages and receive responses.
            // Note: It will configure adb to listen on the port 7634 and forward incoming data via the cable
            //       to Android where adbd will forward it to the port 7634.
            aSender.AttachDuplexOutputChannel(anOutputChannel);
            
            // Send message and wait for the response.
            string aResponse = aSender.SendRequestMessage("Hello.");
            ...
            </code>
            Service code on the Android side.
            <code>
            // Create TCP messaging listening on the same port 7634.
            // Note: Use standard TCP messaging, just listen to the specified port.
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexInputChannel anInputChannel = aMessaging.createDuplexInputChannel("tcp://127.0.0.1:7634/");
            
            // Create message receiver.
            IDuplexTypedMessagesFactory aReceiverFactory = new DuplexTypedMessagesFactory();
            myReceiver = aReceiverFactory.createDuplexTypedMessageReceiver(String.class, String.class);
            
            // Subscribe to receive messages.
            myReceiver.messageReceived().subscribe(new EventHandler&lt;TypedRequestReceivedEventArgs&lt;String&gt;&gt;()
            {
                @Override
                public void onEvent(Object sender, TypedRequestReceivedEventArgs&lt;String&gt; e)
                {
                    // Response back with the same message.
                    try
                    {
                        myReceiver.sendResponseMessage(e.getResponseReceiverId(), e.getRequestMessage());
                    }
                    catch (Exception err)
                    {
                        EneterTrace.error("Sending echo response failed.", err);
                    }
                }
            });
            
            // Attach the input channel to the receiver and start listening.
            myReceiver.attachDuplexInputChannel(anInputChannel);
            </code>
            </example>
            </remarks>
            <param name="channelId">Port number where the Android application is listening.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages via the USB cable to the duplex input channel on Android device.
            </summary>
            <param name="channelId">Port number where the Android application is listening.</param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Not supported. The known restriction is that Android cannot be client. Therefore, .NET or Java application
            running on PC cannot be a service using the duplex input chanel for listening. :-(
            </summary>
            <param name="channelId"></param>
            <returns></returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.SendBufferSize">
            <summary>
            Size of the buffer in bytes for sending messages. Default value is 8192 bytes.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.ReceiveBufferSize">
            <summary>
            Size of the buffer in bytes for receiving messages. Default value is 8192 bytes.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.SendTimeout">
            <summary>
            Sets or gets timeout to send a message. Default is 0 what it infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.ReceiveTimeout">
            <summary>
            Sets or gets timeout to receive a message. If not received within the time the connection is closed. Default is 0 what it infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.ConnectTimeout">
            <summary>
            Sets ot gets timeout to open the connection. Default is 30000 miliseconds. Value 0 is infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory.OutputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel">
            <summary>
            Interface for components which want to attach one IDuplexOutputChannel.
            </summary>
            <remarks>
            Communication components implementing this interface can attach the duplex output channel and
            sends messages and receive response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.AttachDuplexOutputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel)">
            <summary>
            Attaches the duplex output channel and opens the connection for listening to response messages.
            </summary>
            <param name="duplexOutputChannel">Duplex output channel to be attached.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.DetachDuplexOutputChannel">
            <summary>
            Detaches the duplex output channel and stops listening to response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.IsDuplexOutputChannelAttached">
            <summary>
            Returns true if the reference to the duplex output channel is stored. <br/>
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.AttachedDuplexOutputChannel">
            <summary>
            Returns attached duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1">
            <summary>
            Client which can use Remote Procedure Calls (note: it also works with Java and Android).
            </summary>
            <remarks>
            RpcClient acts as a proxy providing the communication functionality allowing a client to call methods exposed by the service.
            </remarks>
            <typeparam name="TServiceInterface">Interface exposed by the service.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1.SubscribeRemoteEvent``1(System.String,System.EventHandler{``0})">
            <summary>
            Subscribes to an event from the service.
            </summary>
            <typeparam name="TEventArgs">Type of the event args. It must be derived from EventArgs.</typeparam>
            <param name="eventName">name of the event</param>
            <param name="eventHandler">event handler processing the event</param>
            <remarks>
            You can use this method for subscribing if you do not want to use the service proxy.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1.UnsubscribeRemoteEvent(System.String,System.Delegate)">
            <summary>
            Unsubscribes from the event in the service.
            </summary>
            <param name="eventName">name of the event</param>
            <param name="eventHandler">event handler that shall be unsubscribed</param>
            <remarks>
            You can use this method for unsubscribing if you do not want to use the service proxy.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1.CallRemoteMethod(System.String,System.Object[])">
            <summary>
            Calls a method in the service.
            </summary>
            <param name="methodName">name of the method that shall be called.</param>
            <param name="args">list of arguments</param>
            <returns>returned value. null if it returns 'void'</returns>
            <remarks>
            You can use this method if you do not want to use the service proxy.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1.ConnectionOpened">
            <summary>
            Event raised when the connection with the service is open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1.ConnectionClosed">
            <summary>
            Event raised when the connection with the service is closed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1.Proxy">
            <summary>
            Returns service proxy instance.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.BinarySerializer">
            <summary>
            Serializes data into .NET specific byte sequence.
            </summary>
            <remarks>
            The serializer internally uses BinaryFormatter provided by .Net.
            The data is serialized in the binary format.
            <br/><br/>
            This serializer is not supported in Silverlight and Windows Phone 7 platforms.
            <br/>
            <example>
            Serialization and deserialization example.
            <code>
            // Some class to be serialized.
            [Serializable]
            public class MyClass
            {
                public int Value1 { get; set; }
                public string Value2 { get; set; }
            }
            
            ...
            
            MyClass c = new MyClass;
            c.Value1 = 10;
            c.Value2 = "Hello World.";
            
            ...
            
            // Serialization
            BinarySerializer aSerializer = new BinarySerializer();
            object aSerializedObject = aSerializer.Serialize&lt;MyClass&gt;(c);
            
            ...
            
            // Deserialization
            BinarySerializer aSerializer = new BinarySerializer();
            object aDeserializedObject = aSerializer.Deserialize&lt;MyClass&gt;(aSerializedObject);
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.ISerializer">
            <summary>
            Declares the serializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.ISerializer.Serialize``1(``0)">
            <summary>
            Serializes data.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>
            Object representing the serialized data.
            Typically it can be byte[] or string.
            </returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.ISerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.BinarySerializer.#ctor">
            <summary>
            Constructs the binary serializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.BinarySerializer.#ctor(System.Boolean)">
            <summary>
            Constructs the binary serializer with a possibility to enforce deserialization into desired type.
            </summary>
            <remarks>
            If the input parameter is false then if the assembly and the namespace of deserialized type does not match with
            the assembly and the namespace of serialized data the exception is thrown.
            If the input parameter is true then the deserialized type does not have to be from the same assembly and the namespace.<br/>
            The defaulat setting is false.
            </remarks>
            <param name="enforceTypeBinding"></param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.BinarySerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the sequnce of bytes, byte[].
            </summary>
            <remarks>
            It internally BinaryFormatter provided by .Net.
            </remarks>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.BinarySerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <remarks>
            It internally BinaryFormatter provided by .Net.
            </remarks>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">the sequence of bytes (byte[]), to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus">
            <summary>
            Message bus.
            </summary>
            <remarks>
            The message bus is the component that allows to dynamically expose various services.
            Services that want to be exposed via the message bus connect the message bus and register their service ids.
            Then, if a client wants to use the service it connects the message bus and asks for the particular service id.
            If such service id exists the message bus mediates the communication between the client and the service.<br/>
            <br/>
            The presence of the message bus is transparent for logic of services and their clients. The whole communication
            is realized via <see cref="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory"/> which ensures the interaction with the message bus.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.AttachDuplexInputChannels(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel,Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel)">
            <summary>
            Attaches duplex input channels that are used by clients and services to connect the message bus.
            </summary>
            <remarks>
            Once input channels are attached the message bus is listening and can be contacted by services and
            clients. <br/>
            <br/>
            To connect the message bus services must use 'Message Bus Duplex Input Channel' and clients must use
            'Message Bus Duplex Output Channel'.<br/>
            <br/>
            IMPORTANT: Both duplex input channels must use the same protocol formatter!
            </remarks>
            <param name="serviceInputChannel">input channel used by services to register in the message bus.</param>
            <param name="clientInputChannel">input channel used by clients to connect a service via the message bus.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.DetachDuplexInputChannels">
            <summary>
            Detaches input channels and stops the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.DisconnectService(System.String)">
            <summary>
            Disconnect and unregisters the specified service.
            </summary>
            <param name="serviceAddress">id of the service that shall be unregistered</param>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.ServiceRegistered">
            <summary>
            The event is raised when a new service is registered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.ServiceUnregistered">
            <summary>
            The event is raised when a service is unregistered.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBus.ConnectedServices">
            <summary>
            Returns list of all connected services.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel">
            <summary>
            Interface for components which want to attach one IDuplexInputChannel.
            </summary>
            <remarks>
            Communication components implementing this interface can attach the duplex input channel and
            receive messages and sends response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.AttachDuplexInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel)">
            <summary>
            Attaches the duplex input channel and starts listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.DetachDuplexInputChannel">
            <summary>
            Detaches the duplex input channel and stops listening to messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.IsDuplexInputChannelAttached">
            <summary>
            Returns true if the duplex input channel is attached.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.AttachedDuplexInputChannel">
            <summary>
            Retutns attached duplex input channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper">
            <summary>
            Duplex channel unwrapper.
            </summary>
            <remarks>
            The duplex channel wrapper is listening to more duplex input channels. When it receives some message,
            it wraps the message and sends it via the only duplex output channel.
            On the other side the message is received by duplex channel unwrapper. The unwrapper unwraps the message
            and uses the duplex output channel to forward the message to the correct receiver.<br/>
            The receiver can also send the response message. Then it goes the same way back.<br/>
            Notice, the 'duplex channel unwrapper' can communication only with 'duplex channel wrapper'.
            It cannot communicate with one-way 'channel wrapper'.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper.GetAssociatedResponseReceiverId(System.String)">
            <summary>
            Returns response receiver id of the client connected to the unwrapper.
            </summary>
            <param name="responseReceiverId">responseRecieverId from unwrapped message</param>
            <returns>responseReceiverId of the client connected to the channel unwrapper. Returns null if it does not exist.</returns>
        </member>
        <member name="E:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper.ResponseReceiverConnected">
            <summary>
            The event is invoked when the duplex channel wrapper opened the connection with this
            unwrapper via its duplex output channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the duplex channel wrapper closed the connection with this
            unwrapper via its duplex output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelUnwrapper.OnResponseReceiverDisconnected(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs)">
            <summary>
            The method is called when the response receiver is disconnected.
            The method clears all connections related to the disconnected receiver.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelUnwrapper.OnResponseMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            Method is called when a response is received from the duplex output channel.
            It wrapps the response and sends the wrapped response to the correct response receiver as the response.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBroker">
            <summary>
            Broker component (for publish-subscribe scenarios).
            </summary>
            <remarks>
            The broker receives messages and forwards them to subscribed clients.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.SendMessage(System.String,System.Object)">
            <summary>
            Publishes the event.
            </summary>
            <param name="eventId">identification of published event.</param>
            <param name="serializedMessage">
            message content. If the message is not a primitive type or string then the input parameter expects the message is already serialized!
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.Subscribe(System.String)">
            <summary>
            Subscribes for the event.
            </summary>
            <remarks>
            If you can call this method multiple times to subscribe for multile events.
            </remarks>
            <param name="eventId">identification of event that shall be observed</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.Subscribe(System.String[])">
            <summary>
            Subscribes for list of events.
            </summary>
            <remarks>
            If you can call this method multiple times to subscribe for multile events.
            </remarks>
            <param name="eventIds">list of events that shall be observed</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.SubscribeRegExp(System.String)">
            <summary>
            Subscribes for event types matching with the given regular expression.
            </summary>
            <remarks>
            When a published message comes to the broker, the broker will check the event id
            and will forward it to all subscribers.<br/>
            The broker will use the given regular expression to recognize whether the client is subscribed
            or not.<br/>
            The .NET based Broker internally uses Regex class to evaluate the regular expression.<br/>
            The Java based Broker internally uses Pattern class to evaluate the regular expression.<br/>
            Regular expressions between .NET and Java does not have to be fully compatible.
            
            <example>
            Few examples for subscribing via regular expression.
            <code>
            // Subscribing for message types starting with the string MyMsg.Speed
            myDuplexBrokerClient.SubscribeRegExp(@"^MyMsg\.Speed);
            
            // Subscribing for message types starting with MyMsg.Speed or App.Utilities
            myDuplexBrokerClient.SubscribeRegExp(@"^MyMsg\.Speed|^App\.Utilities");
            </code>
            </example>
            </remarks>
            <param name="regularExpression">
            Regular expression that will be evaluated by the broker to recognize whether the client is subscribed.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.SubscribeRegExp(System.String[])">
            <summary>
            Subscribes for message types matching with the given list of regular expressions.
            </summary>
            <remarks>
            When a published message comes to the broker, the broker will check the message type id
            and will forward it to all subscribers.<br/>
            The broker will use the given regular expression to recognize whether the client is subscribed
            or not.<br/>
            The .NET based Broker internally uses Regex class to evaluate the regular expression.<br/>
            The Java based Broker internally uses Pattern class to evaluate the regular expression.<br/>
            Regular expressions between .NET and Java does not have to be fully compatible.
            </remarks>
            <param name="regularExpressions">
            List of regular expressions that will be evaluated by the broker to recognize whether the client is subscribed.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.Unsubscribe(System.String)">
            <summary>
            Unsubscribes from the specified event.
            </summary>
            <param name="eventId">type of event which shall not be observed anymore</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.Unsubscribe(System.String[])">
            <summary>
            Unsubscribes from specified events.
            </summary>
            <param name="eventIds">list of events that shall not be observed anymore</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.UnsubscribeRegExp(System.String)">
            <summary>
            Removes the regular expression subscription.
            </summary>
            <remarks>
            When the broker receives this request, it will search if the given regular expression string
            exists for the calling client. If yes, it will be removed.
            </remarks>
            <param name="regularExpression">Regular expression that was previously used for the subscription
            and now shall be removed.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.UnsubscribeRegExp(System.String[])">
            <summary>
            Removes regular expression subscriptions.
            </summary>
            <remarks>
            When the broker receives this request, it will search if the given regular expression strings
            exist for the calling client. If yes, they will be removed.
            </remarks>
            <param name="regularExpressions">Regular expressions that shall be removed from subscriptions.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.Unsubscribe">
            <summary>
            Unsubscribes from all types of events and regular expressions.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.Broker.IDuplexBroker.BrokerMessageReceived">
            <summary>
            The event is invoked when the observed event is received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.NamespaceDoc">
            <summary>
            Extensions for messaging systems.
            </summary>
            <remarks>
            E.g. it is possible to extend the communication by connection monitoring, buffering, authentication or communication via the message bus.
            
            The composite implements IMessagingSystemFactory so it looks like any other messaging but it provides
            some additional behavior which is then applied on the underlying messaging.
            Multiple composite messaging systems can be applied in a "chain". 
            E.g. if you want to have TCP communication with monitored connection and authentication you can
            compose it like in the following example.
            <example>
            Example shows hot composite messaging systems can be chained to create the desired behavior.
            <code>
            // Create TCP messaging system.
            IMessagingSystemFactory anUnderlyingMessaging = new TcpMessagingSystemFactory();
            
            // Create monitored messaging which takes TCP as underlying messaging.
            IMessagingSystemFactory aMonitoredMessaging = new MonitoredMessagingFactory(aTcpMessaging);
            
            // Create messaging with authenticated connection.
            // It takes monitored messaging as the underlying messaging.
            IMessagingSystemFactory aMessaging = new AuthenticatedMessagingFactory(aMonitoredMessaging, ...);
            
            // Creating channels.
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:8095/");
            IDuplexInputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:8095/");
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory">
            <summary>
            Extension providing the connection monitoring.
            </summary>
            <remarks>
            When the connection is monitored, the duplex output channel periodically sends 'ping' messages
            to the duplex input channel and waits for responses.
            If the response comes within the specified timeout, the connection is open.
            <br/>
            On the receiver side, the duplex input channel waits for the 'ping' messages and monitors if the connected
            duplex output channel is still alive. If the 'ping' message does not come within the specified timeout,
            the particular duplex output channel is disconnected.
            <br/><br/>
            Notice, the output channel and the input channel do not maintain an open connection.
            Therefore, the monitored messaging is not applicable for them. The implementation of this factory just uses
            the underlying messaging to create them.
            <br/><br/>
            <b>Note</b>
            Channels created by monitored messaging factory cannot communicate with channels, that were not created
            by monitored factory. E.g. the channel created with the monitored messaging factory with underlying TCP
            will not communicate with channels created directly with TCP messaging factory. The reason is, the
            communicating channels must understand the 'ping' communication.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default settings.
            </summary>
            <remarks>
            It uses <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The duplex output channel will check the connection with the 'ping' once per second and the response must be received within 2 seconds.
            Otherwise the connection is closed.<br/>
            The duplex input channel expects the 'ping' request at least once per 3s (1s + 2s). Otherwise the duplex output
            channel is disconnected.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.TimeSpan,System.TimeSpan)">
            <summary>
            Constructs the factory from specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
            <param name="serializer">serializer used to serialize 'ping' messages</param>
            <param name="pingFrequency">how often the duplex output channel pings the connection</param>
            <param name="pingResponseTimeout">
            For the duplex output channel: the maximum time, the response for the ping must be received
            <br/>
            For the duplex input channel: pingFrequency + pingResponseTimeout = the maximum time within the ping for the connected duplex output channel
            must be received.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            The channel also regularly checks if the connection is available. It sends 'ping' messages and expect 'ping' responses
            within the specified timeout. If the 'ping' response does not come within the specified timeout, the event
            <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> is invoked.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>monitoring duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            The channel also regularly checks if the connection is available. It sends 'ping' messages and expect 'ping' responses
            within the specified timeout. If the 'ping' response does not come within the specified timeout, the event
            <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> is invoked.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">response receiver id of the channel</param>
            <returns>monitoring duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending the response messages.
            </summary>
            <remarks>
            It also checks if the duplex output channel is still connected. It expect, that every connected duplex output channel
            sends regularly 'ping' messages. If the 'ping' message from the duplex output channel is not received within the specified
            timeout, the duplex output channel is disconnected. The event <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected"/>
            is invoked.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>monitoring duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel">
            <summary>
            Duplex input channel that can receive messages from the duplex output channel and send response messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.StartListening">
            <summary>
            Starts listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.StopListening">
            <summary>
            Stops listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.SendResponseMessage(System.String,System.Object)">
            <summary>
            Sends the response message back to the connected IDuplexOutputChannel.
            </summary>
            <param name="responseReceiverId">Identifies the response receiver. The identifier comes with received messages.</param>
            <param name="message">response message</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.DisconnectResponseReceiver(System.String)">
            <summary>
            Disconnects the response receiver.
            </summary>
            <param name="responseReceiverId">identifies the response receiver</param>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverConnected">
            <summary>
            The event is invoked when a duplex output channel opened the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when a duplex output channel closed the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.MessageReceived">
            <summary>
            The event is invoked when a message was received.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ChannelId">
            <summary>
            Returns id of this duplex input channel.
            </summary>
            <remarks>
            The id represents the 'address' the duplex input channel is listening to.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.IsListening">
            <summary>
            Returns true if the duplex input channel is listening.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.Dispatcher">
            <summary>
            Returns dispatcher that defines the threading model for raising events.
            </summary>
            <remarks>
            Dispatcher is responsible for raising ResponseReceiverConnected, ResponseReceiverDisconnected and MessageReceived events
            according to desired thread model.
            E.g. events are queued and raised by one particular thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProviderFactory">
            <summary>
            The interface declares the factory to create the connection provider. The connection provider
            helps to attach a channel to a component or to connect two components with a channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProviderFactory.CreateConnectionProvider(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the connenction provider.
            </summary>
            <param name="messagingSystem">Messaging system the connection provider will use to create channels.</param>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.NamespaceDoc">
            <summary>
            Attaching and detaching communication channels.
            </summary>
            <remarks>
            Communication components attach channels in order to be able to send and receive messages.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels">
            <summary>
            Interface for components which want to attach multiple IDuplexInputChannel.
            </summary>
            <remarks>
            Communication components implementing this interface can attach multiple duplex input channels and listens via them to messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.AttachDuplexInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel)">
            <summary>
            Attaches the duplex input channel nad starts listening to messages.
            </summary>
            <param name="duplexInputChannel">duplex input channel to be attached</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.DetachDuplexInputChannel">
            <summary>
            Detaches the duplex input channel.
            </summary>
            <remarks>
            Detaching the input channel stops listening to the messages.
            It releases listening threads.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.DetachDuplexInputChannel(System.String)">
            <summary>
            Detaches the duplex input channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.IsDuplexInputChannelAttached">
            <summary>
            Returns true if the duplex input channel is attached.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.AttachedDuplexInputChannels">
            <summary>
            Returns attached input channels.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2">
            <summary>
            Reliable typed message receiver (it confirms whether the message was received).
            </summary>
            <remarks>
            Declares the reliable message receiver that can send messages of specified type and sends back response messages of specified type.
            Reliable means it provides events notifying whether the response message was delivered or not.
            The reliable typed message receiver can be used only with the reliable typed message sender.
            </remarks>
            <typeparam name="_ResponseType">type of the response message</typeparam>
            <typeparam name="_RequestType">type of the message</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.SendResponseMessage(System.String,`0)">
            <summary>
            Sends the response message of specified type.
            </summary>
            <param name="responseReceiverId">identifies the response receiver</param>
            <param name="responseMessage">respone message</param>
            <returns>id of the message. The id can be then used to check if the message was received.</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.MessageReceived">
            <summary>
            The event is invoked when the message is received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.ResponseReceiverConnected">
            <summary>
            The event is invoked when the reliable typed message sender opened connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the reliable typed message sender was disconnected.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.ResponseMessageDelivered">
            <summary>
            The event is invoked when the response message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.ResponseMessageNotDelivered">
            <summary>
            The event is invoked when the response message was not delivered within specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender">
            <summary>
            Sender of text messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.SendMessage(System.String)">
            <summary>
            Sends the text message to the response receiver.
            </summary>
            <param name="message">message</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.ConnectionOpened">
            <summary>
            The event is raised when a response message is received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.ConnectionClosed">
            <summary>
            The event is raised when the connection with the receiver is closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.ResponseReceived">
            <summary>
            The event is raised when a response message is received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.NamespaceDoc">
            <summary>
            Communication with Android via the USB cable.
            </summary>
            <example>
            <ul>
                <li><see cref="T:Eneter.Messaging.MessagingSystems.AndroidUsbCableMessagingSystem.AndroidUsbCableMessagingFactory"/> - example a simple desktop application communicating with Android service
                 via the USB cable.</li>
            </ul>
            </example>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBusFactory">
            <summary>
            Creates the message bus.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.IMessageBusFactory.CreateMessageBus">
            <summary>
            Instantiates the message bus.
            </summary>
            <returns>message bus</returns>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.WindowsDispatching">
            <summary>
            Invokes via .NET built in queue System.Windows.Threading.Dispatcher.
            </summary>
            <remarks>
            E.g. in case of WPF it allows to receive message in the UI thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.IThreadDispatcherProvider">
            <summary>
            Provides dispatcher that shall be used for raising events and delivering messages in a correct thread.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.IThreadDispatcherProvider.GetDispatcher">
            <summary>
            Returns dispatcher that will invoke methods according to its threading model.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.WindowsDispatching.#ctor(System.Windows.Threading.Dispatcher)">
            <summary>
            Constructs dispatching which uses windows Dispatcher for invoking incoming methods.
            </summary>
            <param name="windowsDispatcher">windows thread dispatcher.
            E.g. in case of using WPF you can provide the dispatcher associated with the UI thread
            and then GetDispatcher() method will return the dispatcher that will route all methods
            to the UI thread.<br />
            You also can crate your own windows dispatcher that is not associated with UI.
            You can use WindowsDispatching.StartNewWindowsDispatcher() method.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.WindowsDispatching.GetDispatcher">
            <summary>
            Returns dispatcher which invokes incoming methods using the windows dispatcher.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.WindowsDispatching.StartNewWindowsDispatcher">
            <summary>
            Helper method starting a new thread and creating and starting the windows dispatcher for it.
            </summary>
            <remarks>
            This method starts the new thread and then creates the windows dispatcher for it.
            The thread runs in the loop and processes queued methods.<br/>
            Do not forget to call StopWindowsDispatcher() to release the looping thread.
            Otherwise the thread will leak and can cause the application will hang when closed.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.WindowsDispatching.StopWindowsDispatcher(System.Windows.Threading.Dispatcher)">
            <summary>
            Releases the thread waiting in the windows dispatcher queue for delegates that shall be invoked.
            </summary>
            <param name="dispatcher">dispatcher that shall be stopped</param>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.IThreadDispatcher">
            <summary>
            Invokes a method according to specified thread mode.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.IThreadDispatcher.Invoke(System.Action)">
            <summary>
            Invokes method in desired thread.
            </summary>
            <param name="workItem">delegate to be invoked</param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1">
            <summary>
            Declares functionality to encode and decode messages used for the communication between channels. 
            </summary>
            <typeparam name="T">type of encoded data. It can be byte[] or String.</typeparam>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter">
            <summary>
            Declares functionality to encode and decode messages used for the communication between channels.
            </summary>
            <remarks>
            Encoded messages are presented as type of object. This interface is used if it is not needed to know
            if the encoded messages are byte[] or string.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeOpenConnectionMessage(System.String)">
            <summary>
            Encodes the open connection request message.
            </summary>
            <remarks>
            The message is used by the duplex output channel to open the connection with the duplex input channel.
            </remarks>
            <param name="responseReceiverId">id of the client opening the connection.</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeOpenConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Encodes the open connection request message to the stream.
            </summary>
            <param name="responseReceiverId">id of the client opening the connection.</param>
            <param name="outputSream">output where the encoded message is written</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeCloseConnectionMessage(System.String)">
            <summary>
            Encodes the close connecion request message.
            </summary>
            <remarks>
            The message is used by the duplex output channel or duplex input channel to close the connection.
            </remarks>
            <param name="responseReceiverId">id of the client that wants to disconnect or that will be disconnected</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeCloseConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Encodes the close connecion request message to the stream.
            </summary>
            <param name="responseReceiverId">id of the client that wants to disconnect or that will be disconnected</param>
            <param name="outputSream">output where the encoded message is written</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeMessage(System.String,System.Object)">
            <summary>
            Encodes a message or a response message.
            </summary>
            <remarks>
            The message is used by output channel or duplex output channel to send messages or
            by duplex input channel to send response messages.
            </remarks>
            <param name="responseReceiverId">client id. It is empty string in case of output channel.</param>
            <param name="message">message serialized message to be sent.</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeMessage(System.String,System.Object,System.IO.Stream)">
            <summary>
            Encodes a message or a response message to the stream.
            </summary>
            <param name="responseReceiverId">id of the client that wants to send the message. It is empty string if the response message is sent.</param>
            <param name="message">serialized message to be sent.</param>
            <param name="outputSream">output where the encoded message is written</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.DecodeMessage(System.IO.Stream)">
            <summary>
            Decodes message from the stream.
            </summary>
            <param name="readStream">stream to be read</param>
            <returns>decoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.DecodeMessage(System.Object)">
            <summary>
            Decodes message from the given object.
            </summary>
            <param name="readMessage">reference to the object.</param>
            <returns>decoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1.EncodeOpenConnectionMessage(System.String)">
            <summary>
            Encodes the open connection request message.
            </summary>
            <remarks>
            The message is used by the duplex output channel to open the connection with the duplex input channel.
            </remarks>
            <param name="responseReceiverId">id of the client opening the connection.</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1.EncodeCloseConnectionMessage(System.String)">
            <summary>
            Encodes the close connecion request message.
            </summary>
            <remarks>
            The message is used by the duplex output channel or duplex input channel to close the connection.
            </remarks>
            <param name="responseReceiverId">id of the client that wants to disconnect or that will be disconnected</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1.EncodeMessage(System.String,System.Object)">
            <summary>
            Encodes a message or a response message.
            </summary>
            <remarks>
            The message is used by output channel or duplex output channel to send messages or
            by duplex input channel to send response messages.
            </remarks>
            <param name="responseReceiverId">id of the client that wants to send the message. It is empty string if the response message is sent.</param>
            <param name="message">serialized message to be sent.</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1.DecodeMessage(System.IO.Stream)">
            <summary>
            Decodes message from the stream.
            </summary>
            <param name="readStream">stream to be read</param>
            <returns>decoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1.DecodeMessage(`0)">
            <summary>
            Decodes message from the given object.
            </summary>
            <param name="readMessage">reference to the object.</param>
            <returns>decoded message</returns>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.ConnectionProviderFactory">
            <summary>
            Implements the factory to create the connection provider. The connection provider
            helps to attach a channel to a component or to connect two components with a channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.ConnectionProviderFactory.CreateConnectionProvider(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the connection provider.
            </summary>
            <param name="messagingSystem">Messaging system the connection provider will use to create channels.</param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2">
            <summary>
            Reliable typed message sender (it confirms whether the message was received).
            </summary>
            <remarks>
            Declares reliable message sender which can send messages of specified type and receive response messages of specified type.
            Reliable means it provides events notifying whether the message was delivered.
            The reliable typed message sender can be used only with the reliable typed message receiver.
            </remarks>
            <typeparam name="_ResponseType">type of the response message</typeparam>
            <typeparam name="_RequestType">type of the message</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.SendRequestMessage(`1)">
            <summary>
            Sends the message of specified type.
            </summary>
            <param name="message">message to be sent</param>
            <returns>id of the message. The id can be then used to check if the message was received.</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.ConnectionOpened">
            <summary>
            The event is raised when the connection with the receiver is open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.ConnectionClosed">
            <summary>
            The event is raised when the connection with the receiver is closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.ResponseReceived">
            <summary>
            The event is invoked when the response message is received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.MessageDelivered">
            <summary>
            The event is invoked when the message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.MessageNotDelivered">
            <summary>
            The event is invoked if the event is not delivered within a specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2">
            <summary>
            Receiver of typed messages.
            </summary>
            <typeparam name="_ResponseType">sends response messages of this type.</typeparam>
            <typeparam name="_RequestType">receives messages of this type.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.SendResponseMessage(System.String,`0)">
            <summary>
            Sends the response message back to the duplex typed message sender via the attached duplex input channel.
            </summary>
            <param name="responseReceiverId">identifies the duplex typed message sender that will receive the response</param>
            <param name="responseMessage">response message</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.MessageReceived">
            <summary>
            The event is invoked when the message from a duplex typed message sender was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.ResponseReceiverConnected">
            <summary>
            The event is invoked when a duplex typed message sender opened the connection via its duplex output channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when a duplex typed message sender closed the connection via its duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage">
            <summary>
            Represents a data message received via websocket communication.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage.#ctor(System.Boolean,System.IO.Stream)">
            <summary>
            Constructs the message - only eneter framework can construct it.
            </summary>
            <param name="isText">true if it is a text message.</param>
            <param name="inputStream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage.GetWholeMessage">
            <summary>
            Returns the whole incoming message.
            </summary>
            <remarks>
            In case the message was sent via multiple frames it waits until all frames are
            collected and then returns the result message.
            </remarks>
            <returns>received message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage.GetWholeTextMessage">
            <summary>
            Returns the whole incoming text message.
            </summary>
            <remarks>
            In case the message was sent via multiple frames it waits until all frames are
            collected and then returns the result message.<br/>
            To receive message as a text message, according to websocket protocol the message
            must be sent via the text frame.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            The message wsa not sent/received as the text message.
            I.e. the message was not sent via the text frame.
            </exception>
            <returns>received text message</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage.IsText">
            <summary>
            Returns true if the message is text. The message is text when sent via text frame.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketMessage.InputStream">
            <summary>
            Returns the input stream user can use to read the message from.
            </summary>
            <remarks>
            The reading of the stream blocks if desired amount of data is not available and
            not all message frames were received.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.NamespaceDoc">
            <summary>
            SSL, Negotiate or Non-security protocol for the TCP communication.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ISecurityFactory">
            <summary>
            Creates the network stream.
            </summary>
            <remarks>
            The security stream wrapps the source stream and provides functionality for authentication (verifying communicating parts),
            encryption (writes encrypted data to the wrapped stream) and decryption (decrypts data from the wrapped stream).
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ISecurityFactory.CreateSecurityStreamAndAuthenticate(System.IO.Stream)">
            <summary>
            Creates the security stream and performs the authentication.
            </summary>
            <param name="source">The stream wrapped by the security stream.</param>
            <returns>Security stream.</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientNegotiateFactory">
            <summary>
            The factory class creating the security stream allowing the authentication and encrypted communication
            based on 'Negotiate communication protocol'.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientNegotiateFactory.#ctor">
            <summary>
            Constructs the factory that will use client's default credentials and the service principal name will not be specified.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientNegotiateFactory.#ctor(System.Net.NetworkCredential,System.String)">
            <summary>
            Constructs the factory that will use the specified user credentials and specified service principal name.
            </summary>
            <param name="networkCredential">identity of the client</param>
            <param name="servicePrincipalName">service principal name that uniquely identifies the server to authenticate</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientNegotiateFactory.CreateSecurityStreamAndAuthenticate(System.IO.Stream)">
            <summary>
            Creates security stream and authenticates as client.
            </summary>
            <param name="source">The stream wrapped by the security stream.</param>
            <returns>Security stream of type NegotiateStream.</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1">
            <summary>
            Abstract internal class providing default implementation for formatting communication before channels.
            </summary>
            <remarks>
            The default implemention of all methods throws NotSupportedException.
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1.EncodeOpenConnectionMessage(System.String)">
            <summary>
            Returns encoded 'open connection' message.
            </summary>
            <param name="responseReceiverId"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1.EncodeOpenConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Encodes 'open connection' message directly to the stream.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="outputSream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1.EncodeCloseConnectionMessage(System.String)">
            <summary>
            Returns encoded 'close connection' message.
            </summary>
            <param name="responseReceiverId"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1.EncodeCloseConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Encodes 'close connection' message directly to the stream.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="outputSream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1.EncodeMessage(System.String,System.Object)">
            <summary>
            Returns encoded 'request message' or 'response message'.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1.EncodeMessage(System.String,System.Object,System.IO.Stream)">
            <summary>
            Encodes 'request message' or 'response message' directly to the stream.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="message"></param>
            <param name="outputSream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1.DecodeMessage(System.IO.Stream)">
            <summary>
            Decodes a message from the stream.
            </summary>
            <param name="readStream"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1.DecodeMessage(`0)">
            <summary>
            Decodes the message.
            </summary>
            <param name="readMessage"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.SerializerExt.Serialize(Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Type,System.Object)">
            <summary>
            Serializes using Type instead of generics.
            </summary>
            <param name="serializer">serializer derived from ISerializer</param>
            <param name="dataType">type of serialized data</param>
            <param name="dataToSerialzier">data to be serialized</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.SerializerExt.Deserialize(Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Type,System.Object)">
            <summary>
            Deserializes using Type instead of generics.
            </summary>
            <param name="serializer">serializer derived from ISerializer</param>
            <param name="dataType">type of deserialized data</param>
            <param name="serializedData">data to be deserialized</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.DataContractJsonStringSerializer">
            <summary>
            Serializes data into JSON.
            </summary>
            <remarks>
            The serializer is based on DataContractJsonSerializer provided by .Net and it supports
            attributes (DataContract, DataMember, ...) specifying how data is serialized/deserialized.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractJsonStringSerializer.#ctor">
            <summary>
            Creates the serializer based on DataContractSerializer with default settings.
            </summary>
            <remarks>
            XmlDictionaryReaderQuotas are set to Max values.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractJsonStringSerializer.#ctor(System.Xml.XmlDictionaryReaderQuotas)">
            <summary>
            Creates serializer based on DataContractJsonSerializer.
            </summary>
            <param name="quotas">various quotas vsalues for the deserialization.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractJsonStringSerializer.#ctor(System.Xml.XmlDictionaryReaderQuotas,System.Func{System.Type,System.Runtime.Serialization.XmlObjectSerializer})">
            <summary>
            Creates the serializer that allows user to specify his own method to instantiate DataContractJsonSerializer
            with desired settings.
            </summary>
            <param name="quotas">various quotas vsalues for the deserialization.</param>
            <param name="dataContractFactoryMethod">
            The factory method responsible for creation of DataContractJsonSerializer.
            The factory method is called during the serialization or deserialization.<br/>
            The factory method can be called from more threads at the same time, so be sure, your factory method
            is thread safe.
            </param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractJsonStringSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the JSON string.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>JSON string</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractJsonStringSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes JSON string into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data serialized in JSON string.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.WinFormsDispatching">
            <summary>
            Invokes to WinForms main UI thread.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.WinFormsDispatching.#ctor(System.Windows.Forms.Control)">
            <summary>
            Constructs the dispatcher provider.
            </summary>
            <param name="dispatcher">UI control e.g. WinForm which represents the thread where invokes shall be routed.</param>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.WinFormsDispatching.GetDispatcher">
            <summary>
            Returns the thread dispatcher which routes invokactions into the WinForms UI thread.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs">
            <summary>
            Event type for text request message is received.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructs the event from thr parameters.
            </summary>
            <param name="requestMessage"></param>
            <param name="responseReceiverId"></param>
            <param name="senderAddress"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.RequestMessage">
            <summary>
            Returns the request message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.ResponseReceiverId">
            <summary>
            Returns the response receiver id.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.SenderAddress">
            <summary>
            Returns the address where the sender of the request message is located. (e.g. IP address of the client).
            It can be empty string if not applicable for used messaging.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.BackupRouter.NamespaceDoc">
            <summary>
            Automatic routing to a backup server in case of a disconnection.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory">
            <summary>
            The factory class creating the security stream allowing authentication as client and encrypted communication
            based on SSL protocol.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory.#ctor(System.String)">
            <summary>
            Constructs the factory for the case where only the server identity is verifyied.
            </summary>
            <param name="hostName">The host the client wants to communicate with. The host name must match with the certificate name.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory.#ctor(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection)">
            <summary>
            Constructs the factory for the case where server identity and also the client identity are verifyied.
            </summary>
            <param name="hostName">The host the client wants to communicate with. The host name must match with the certificate name.</param>
            <param name="clientCertificates">List of certificates provided by the client. If null, the client is not verified.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory.#ctor(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <summary>
            Constructs the factory for the case where server identity and also the client identity can be verifyied.
            </summary>
            <param name="hostName">The host the client wants to communicate with. The host name must match with the certificate name.</param>
            <param name="certificates">List of certificates provided by the client. If null, the client is not verified.</param>
            <param name="userCertificateValidationCallback">User provided delegate for validating the certificate supplied by the remote party.</param>
            <param name="userCertificateSelectionCallback">User provided delegate for selecting the certificate used for authentication.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ClientSslFactory.CreateSecurityStreamAndAuthenticate(System.IO.Stream)">
            <summary>
            Creates the security stream and performs the authentication as client.
            </summary>
            <param name="source">The stream wrapped by the security stream.</param>
            <returns>Security stream of type SslStream.</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.NamespaceDoc">
            <summary>
            Remote Procedure Calls (RPC).
            </summary>
            <example>
            For more details see example:
            <ul>
            <li>Simple calculator service - <see cref="T:Eneter.Messaging.EndPoints.Rpc.RpcFactory"/></li>
            </ul>
            </example>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer">
            <summary>
            Serializer using Rijndael encryption.
            </summary>
            <remarks>
            The serializer internally uses some other serializer to serialize and deserialize data.
            Then it uses Rijndael to encrypt and decrypt the data.
            <br/><br/>
            Notice, the Rijndael encryption is not available in Silverlight platform.
            <example>
            Encrypted serialization with <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>
            <code>
            // Create the serializer. The defualt constructor uses XmlStringSerializer.
            RijndaelSerializer aSerializer = new RijndaelSerializer("My password.");
            
            // Create some data to be serialized.
            MyData aData = new MyData();
            ...
            
            // Serialize data with using Rijndael.
            object aSerializedData = aSerializer.Serialize&lt;MyData&gt;(aData);
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.#ctor(System.String)">
            <summary>
            Constructs the serializer. It uses <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/> as the underlying serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.#ctor(System.String,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.#ctor(System.String,System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
            <param name="salt">additional value used to calculate the key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.#ctor(System.String,System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Int32)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate the key</param>
            <param name="salt">additional value used to calculate the key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
            <param name="keyBitSize">bit size of the key e.g. 128, 256</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Security.Cryptography.DeriveBytes,System.Int32)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
            <param name="passwordBasedKeyGenerator">generator of key from the password</param>
            <param name="keyBitSize">bit size of the key</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the object.
            The returned object is type of byte[]. Returned bytes are encrypted.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RijndaelSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Encrypted data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.AsyncDispatching">
            <summary>
            Invokes asynchronously by routing to a thread from the thread-pool (each method can be executed in a separate thread).
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.AsyncDispatching.GetDispatcher">
            <summary>
            Returns dispatcher which invokes asynchronously in a thread from the thread-pool.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetLoginMessage">
            <summary>
            Callback providing the login message.
            </summary>
            <remarks>
            Returned login message must be String or byte[].
            </remarks>
            <param name="channelId">service address</param>
            <param name="responseReceiverId">unique id representing the connection with the client</param>
            <returns>login message (must be String or byte[])</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetHanshakeMessage">
            <summary>
            Callback method to get the handshake message.
            </summary>
            <remarks>
            When AuthenticatedDuplexInputChannel receives the login message this callback is called to get
            the handshake message.
            The handshake message is then sent to the connecting AuthenticatedDuplexOutputChannel which will process it
            and send back the handshake response message.<br/>
            <br/>
            Returned handshake message must be String or byte[].
            If it returns null it means the connection will be closed. (e.g. if the login message was not accepted.)
            </remarks>
            <param name="channelId">service address</param>
            <param name="responseReceiverId">unique id representing the connection with the client</param>
            <param name="loginMessage">login message received from the client</param>
            <returns>handshake message (must be String or byte[])</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetHandshakeResponseMessage">
            <summary>
            Callback method to get the response message for the handshake message.
            </summary>
            <remarks>
            When AuthenticatedDuplexOutputChannel receives the handshake message it calls this callback to get
            the response message for the handshake message.
            The response handshake message is then sent to AuthenticatedDuplexInputChannel which will
            then authenticate the connection.<br/>
            <br/>
            Returned response message must be String or byte[].
            If it returns null then it means the handshake message is not accepted and the connection will be closed.
            </remarks>
            <param name="channelId">service address</param>
            <param name="responseReceiverId">unique id representing the connection with the client</param>
            <param name="handshakeMessage">handshake message received from the service</param>
            <returns>response message (must be String or byte[])</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.Authenticate">
            <summary>
            Callback method to authenticate the connection.
            </summary>
            <remarks>
            If it returns true the connection will be established.
            If it returns false the connection will be closed.
            </remarks>
            <param name="channelId">service address</param>
            <param name="responseReceiverId">unique id representing the connection with the client</param>
            <param name="loginMessage">login message that was sent from the client</param>
            <param name="handshakeMessage">verification message (question) that service sent to the client</param>
            <param name="handshakeResponseMessage">client's response to the handshake message</param>
            <returns>true if the authentication passed and the connection can be established</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory">
            <summary>
            Extension performing the authentication during connecting.
            </summary>
            <remarks>
            Here is how the authentication procedure works:
            <ol>
            <li>AuthenticatedDuplexOutputChannel calls getLoginMessage callback and sends the login message and
                sends it to AuthenticatedDuplexInputChannel.</li>
            <li>AuthenticatedDuplexInputChannel receives the login message and calls getHandshakeMessage callback.
                The returned handshake message is sent to AuthenticatedDuplexOutputChannel.</li>
            <li>AuthenticatedDuplexOutputChannel receives the handshake message and calls getHandshakeResponseMessage.
                The returned handshake response message is then sent to AuthenticatedDuplexInputChannel.</li>
            <li>AuthenticatedDuplexInputChannel receives the handshake response message and calls authenticate callback.
                if it returns true the connection is established.</li>
            </ol>
            
            <example>
            Service side using the authentication:
            <code>
            class Program
            {
                private static Dictionary&lt;string, string&gt; myUsers = new Dictionary&lt;string, string&gt;();
                private static IDuplexStringMessageReceiver myReceiver;
            
                static void Main(string[] args)
                {
                    //EneterTrace.TraceLog = new StreamWriter("d:/tracefile.txt");
            
                    // Simulate users.
                    myUsers["John"] = "password1";
                    myUsers["Steve"] = "password2";
            
                    // Create TCP based messaging.
                    IMessagingSystemFactory aTcpMessaging = new TcpMessagingSystemFactory();
            
                    // Connecting clients will be authenticated.
                    IMessagingSystemFactory aMessaging = new AuthenticatedMessagingFactory(aTcpMessaging, GetHandshakeMessage, Authenticate);
                    IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:8092/");
            
                    // Use text messages.
                    IDuplexStringMessagesFactory aStringMessagesFactory = new DuplexStringMessagesFactory();
                    myReceiver = aStringMessagesFactory.CreateDuplexStringMessageReceiver();
                    myReceiver.RequestReceived += OnRequestReceived;
            
                    // Attach input channel and start listening.
                    // Note: using AuthenticatedMessaging will ensure the connection will be established only
                    //       if the authentication procedure passes.
                    myReceiver.AttachDuplexInputChannel(anInputChannel);
            
                    Console.WriteLine("Service is running. Press Enter to stop.");
                    Console.ReadLine();
            
                    // Detach input channel and stop listening.
                    // Note: tis will release the listening thread.
                    myReceiver.DetachDuplexInputChannel();
                }
            
                private static void OnRequestReceived(object sender, StringRequestReceivedEventArgs e)
                {
                    // Handle received messages here.
                    Console.WriteLine(e.RequestMessage);
            
                    // Send back the response.
                    myReceiver.SendResponseMessage(e.ResponseReceiverId, "Hello");
                }
            
                private static object GetHandshakeMessage(string channelId, string responseReceiverId, object loginMessage)
                {
                    // Check if login is ok.
                    if (loginMessage is string)
                    {
                        string aLoginName = (string)loginMessage;
                        if (myUsers.ContainsKey(aLoginName))
                        {
                            // Login is OK so generate the handshake message.
                            // e.g. generate GUI.
                            return Guid.NewGuid().ToString();
                        }
                    }
                    
                    // Login was not ok so there is not handshake message
                    // and the connection will be closed.
                    EneterTrace.Warning("Login was not ok. The connection will be closed.");
                    return null;
                }
            
                private static bool Authenticate(string channelId, string responseReceiverId, object loginMessage,
                    object handshakeMessage, object handshakeResponseMessage)
                {
                    if (loginMessage is string)
                    {
                        // Get the password associated with the user.
                        string aLoginName = (string) loginMessage;
                        string aPassword;
                        myUsers.TryGetValue(aLoginName, out aPassword);
                        
                        // E.g. handshake response may be encrypted original handshake message.
                        //      So decrypt incoming handshake response and check if it is equal to original handshake message.
                        try
                        {
                            ISerializer aSerializer = new AesSerializer(aPassword);
                            string aDecodedHandshakeResponse = aSerializer.Deserialize&lt;string&gt;(handshakeResponseMessage);
                            string anOriginalHandshake = (string) handshakeMessage;
                            if (anOriginalHandshake == aDecodedHandshakeResponse)
                            {
                                // The handshake response is correct so the connection can be established.
                                return true;
                            }
                        }
                        catch (Exception err)
                        {
                            // Decoding of the response message failed.
                            // The authentication will not pass.
                            EneterTrace.Warning("Decoding handshake message failed.", err);
                        }
                    }
                    
                    // Authentication did not pass.
                    EneterTrace.Warning("Authentication did not pass. The connection will be closed.");
                    return false;
                }
            }
            </code>
            </example>
            
            <example>
            Client using the authentication:
            <code>
            class Program
            {
                private static IDuplexStringMessageSender mySender;
            
                static void Main(string[] args)
                {
                    // TCP messaging.
                    IMessagingSystemFactory aTcpMessaging = new TcpMessagingSystemFactory();
                
                    // Authenticated messaging uses TCP as the underlying messaging.
                    IMessagingSystemFactory aMessaging = new AuthenticatedMessagingFactory(aTcpMessaging, GetLoginMessage, GetHandshakeResponseMessage);
                    IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:8092/");
                
                    // Use text messages.
                    mySender = new DuplexStringMessagesFactory().CreateDuplexStringMessageSender();
                
                    // Subscribe to receive response messages.
                    mySender.ResponseReceived += OnResponseMessageReceived;
                
                    // Attach output channel and connect the service.
                    mySender.AttachDuplexOutputChannel(anOutputChannel);
                
                    // Send a message.
                    mySender.SendMessage("Hello");
                
                    Console.WriteLine("Client sent the message. Press ENTER to stop.");
                    Console.ReadLine();
                
                    // Detach output channel and stop listening.
                    // Note: it releases the tread listening to responses.
                    mySender.DetachDuplexOutputChannel();
                }
            
                private static void OnResponseMessageReceived(object sender, StringResponseReceivedEventArgs e)
                {
                    // Process the incoming response here.
                    Console.WriteLine(e.ResponseMessage);
                }
            
                public static object GetLoginMessage(string channelId, string responseReceiverId)
                {
                    return "John";
                }
            
                public static object GetHandshakeResponseMessage(string channelId, string responseReceiverId, object handshakeMessage)
                {
                    try
                    {
                        // Handshake response is encoded handshake message.
                        ISerializer aSerializer = new AesSerializer("password1");
                        object aHandshakeResponse = aSerializer.Serialize&lt;string&gt;((string)handshakeMessage);
                        
                        return aHandshakeResponse;
                    }
                    catch (Exception err)
                    {
                        EneterTrace.Warning("Processing handshake message failed. The connection will be closed.", err);
                    }
                    
                    return null;
                }
            }
            </code>
            </example>
            
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetLoginMessage,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetHandshakeResponseMessage)">
            <summary>
            Constructs factory that will be used only by a client.
            </summary>
            <remarks>
            The constructor takes only callbacks which are used by the client. Therefore if you use this constructor
            you can create only duplex output channels.
            </remarks>
            <param name="underlyingMessagingSystem">underlying messaging upon which the authentication will work.</param>
            <param name="getLoginMessageCallback">callback returning the login message.</param>
            <param name="getHandshakeResponseMessageCallback">callback returning the response message for the handshake.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetHanshakeMessage,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.Authenticate)">
            <summary>
            Constructs factory that will be used only by a service.
            </summary>
            <remarks>
            The constructor takes only callbacks which are used by the service. Therefore if you use this constructor
            you can create only duplex input channels.
            </remarks>
            <param name="underlyingMessagingSystem">underlying messaging upon which the authentication will work.</param>
            <param name="getHandshakeMessageCallback">callback returning the handshake message.</param>
            <param name="authenticateCallback">callback performing the authentication.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetLoginMessage,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetHandshakeResponseMessage,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetHanshakeMessage,Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.Authenticate)">
            <summary>
            Constructs factory that can be used by client and service simultaneously.
            </summary>
            <remarks>
            If you construct the factory with this constructor you can create both duplex output channels and
            duplex input channels.
            </remarks>
            <param name="underlyingMessagingSystem">underlying messaging upon which the authentication will work.</param>
            <param name="getLoginMessageCallback">returning the login message.</param>
            <param name="getHandshakeResponseMessageCallback">callback returning the response message for the handshake.</param>
            <param name="getHandshakeMessageCallback">callback returning the handshake message.</param>
            <param name="authenticateCallback">callback performing the authentication.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates duplex output channel which performs authentication procedure during opening the connection.
            </summary>
            <param name="channelId">service address</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates duplex output channel which performs authentication procedure during opening the connection.
            </summary>
            <param name="channelId">service address</param>
            <param name="responseReceiverId">unique identifier of the connection with the service.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates duplex input channel which performs the authentication procedure.
            </summary>
            <param name="channelId">service address</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.AuthenticationTimeout">
            <summary>
            Gets/sets maximum time until the authentication procedure must be performed.
            </summary>
            <remarks>
            The timeout is applied in duplex output channel. If the authentication is not completed within the specified time
            TimeoutException is thrown.<br/>
            Timeout is set to 30 seconds by default.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.OutputChannelThreading">
            <summary>
            Gets or sets the threading mode for the authenticated output channel.
            </summary>
            <remarks>
            When opening connection the authenticated output channel communicates with the authenticated input channel.
            During this communication the openConnection() is blocked until the whole authentication communication is performed.
            It means if openConnection() is called from the same thread into which the underlying duplex output channel
            routes events the openConneciton() would get into the deadlock (because the underlying output channel would
            route authentication messages into the same thread).<br/>
            <br/>
            Therefore it is possible to set the threading mode of the authenticated output channel independently. 
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs">
            <summary>
            Event arguments of the received message from the broker.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.#ctor(System.String,System.Object)">
            <summary>
            Constructs the event from the input parameters.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.#ctor(System.Exception)">
            <summary>
            Constructs the event from the error detected during receiving of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.MessageTypeId">
            <summary>
            Returns type of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.Message">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider">
            <summary>
            The interface declares methods for convenient attaching of channels and
            for connecting senders and receivers with channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel,System.String)">
            <summary>
            Creates and attaches the duplex input channel to the component.
            </summary>
            <param name="inputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels,System.String)">
            <summary>
            Creates and attaches the duplex input channel to the component that can have attached multiple duplex input channels.
            </summary>
            <param name="inputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel,System.String)">
            <summary>
            Creates and attaches the duplex output channel to the component.
            </summary>
            <param name="outputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel,Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel,System.String)">
            <summary>
            Creates the duplex input channel and duplex output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">duplex input channel attachable component (receiver)</param>
            <param name="outputComponent">duplex output channel attachable component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels,Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel,System.String)">
            <summary>
            Creates the duplex input channel and duplex output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">duplex input channel attachable component (receiver)</param>
            <param name="outputComponent">duplex output channel attachable component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.MessagingSystem">
            <summary>
            Returns the messaging system used by the connection provider.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1">
            <summary>
            Event argument used when a typed response message is received.
            </summary>
            <typeparam name="_ResponseMessageType">message type</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.#ctor(`0)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseMessage">response message</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event from the exception detected during receiving the response message.
            </summary>
            <param name="error"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.ResponseMessage">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns an exception detected during receiving the response message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory">
            <summary>
            Declares the factory for creating channel wrappers and and channel unwrappers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateDuplexChannelWrapper">
            <summary>
            Creates the duplex channel wrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateDuplexChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the duplex channel unwrapper.
            </summary>
            <param name="outputMessagingSystem">Messaging used to create output channels where unwrapped messages will be sent.</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.NamespaceDoc">
            <summary>
            Communication via TCP.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerNegotiateFactory">
            <summary>
            The factory class creating the security stream allowing authentication as server and encrypted communication
            based on 'Negotiate communication protocol'.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerNegotiateFactory.CreateSecurityStreamAndAuthenticate(System.IO.Stream)">
            <summary>
            Creates security stream and authenticates as server.
            </summary>
            <param name="source">The stream wrapped by the security stream.</param>
            <returns>Security stream of type NegotiateStream.</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.DefaultMessagingSystemFactory.InputChannelThreading">
            <summary>
            Sets/gets threading mode for input channels.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.DefaultMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Sets/gets threading mode used for input channels.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.NamespaceDoc">
            <summary>
            Extension providing communication via the message bus. (Exposing multiple services from one place.)
            </summary>
            <remarks>
            The message bus is the component that can be used to expose multiple services from one place.
            When a service wants to expose its functionality via the message bus it connects the message bus and registers there.
            Then when a client wants to use the service it connects the message bus and asks for the service.
            If the requested service is registered the communication between the client and the service is mediated via the message bus.<br/>
            </remarks>
            <example>
            For more details see examples:
            <ul>
                <li><see cref="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory"/> - exposing a simple service via the message bus.</li>
            </ul>
            </example>
        </member>
        <member name="T:ReadOnlyDictionary`2">
            <summary>
            Provides the base class for a generic read-only dictionary.
            </summary>
            <typeparam name="TKey">
            The type of keys in the dictionary.
            </typeparam>
            <typeparam name="TValue">
            The type of values in the dictionary.
            </typeparam>
            <remarks>
            <para>
            An instance of the <b>ReadOnlyDictionary</b> generic class is
            always read-only. A dictionary that is read-only is simply a
            dictionary with a wrapper that prevents modifying the
            dictionary; therefore, if changes are made to the underlying
            dictionary, the read-only dictionary reflects those changes. 
            See <see cref="T:System.Collections.Generic.Dictionary`2"/> for a modifiable version of 
            this class.
            </para>
            <para>
            <b>Notes to Implementers</b> This base class is provided to 
            make it easier for implementers to create a generic read-only
            custom dictionary. Implementers are encouraged to extend this
            base class instead of creating their own. 
            </para>
            </remarks>
        </member>
        <member name="M:ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Initializes a new instance of the
            <see cref="T:ReadOnlyDictionary`2" /> class that wraps
            the supplied <paramref name="dictionaryToWrap"/>.
            </summary>
            <param name="dictionaryToWrap">The <see cref="T:IDictionary`2" />
            that will be wrapped.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the dictionary is null.
            </exception>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Add(`0,`1)">
            <summary>This method is not supported by the 
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="key">
            The object to use as the key of the element to add.</param>
            <param name="value">
            The object to use as the value of the element to add.</param>
        </member>
        <member name="M:ReadOnlyDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the <see cref="T:ReadOnlyDictionary`2" />
            contains the specified key.</summary>
            <returns>
            True if the <see cref="T:ReadOnlyDictionary`2" /> contains
            an element with the specified key; otherwise, false.
            </returns>
            <param name="key">The key to locate in the
            <see cref="T:ReadOnlyDictionary`2"></see>.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the key is null.
            </exception>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Remove(`0)">
            <summary>
            This method is not supported by the <see cref="T:ReadOnlyDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>
            True if the element is successfully removed; otherwise, false.
            </returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get.</param>
            <param name="value">When this method returns, contains the value
            associated with the specified key, if the key is found;
            otherwise, the default value for the type of the value parameter.
            This parameter is passed uninitialized.</param>
            <returns>
            <b>true</b> if the <see cref="T:ReadOnlyDictionary`2" /> contains
            an element with the specified key; otherwise, <b>false</b>.
            </returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>This method is not supported by the
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="item">
            The object to add to the <see cref="T:ICollection`1"/>.
            </param>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Clear">
            <summary>This method is not supported by the 
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether the <see cref="T:ICollection`1"/> contains a
            specific value.
            </summary>
            <param name="item">
            The object to locate in the <see cref="T:ICollection`1"/>.
            </param>
            <returns>
            <b>true</b> if item is found in the <b>ICollection</b>; 
            otherwise, <b>false</b>.
            </returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the elements of the ICollection to an Array, starting at a
            particular Array index. 
            </summary>
            <param name="array">The one-dimensional Array that is the
            destination of the elements copied from ICollection.
            The Array must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            The zero-based index in array at which copying begins.
            </param>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>This method is not supported by the
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="item">
            The object to remove from the ICollection.
            </param>
            <returns>Will never return a value.</returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey@TValue}}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A IEnumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An IEnumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:ReadOnlyDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            For a description of this member, see <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>. 
            </summary>
            <param name="array">
            The one-dimensional Array that is the destination of the elements copied from 
            ICollection. The Array must have zero-based indexing.
            </param>
            <param name="index">
            The zero-based index in Array at which copying begins.
            </param>
        </member>
        <member name="P:ReadOnlyDictionary`2.Count">
            <summary>
            Gets the number of key/value pairs contained in the
            <see cref="T:ReadOnlyDictionary`2"></see>.
            </summary>
            <value>The number of key/value pairs.</value>
            <returns>The number of key/value pairs contained in the
            <see cref="T:ReadOnlyDictionary`2"></see>.</returns>
        </member>
        <member name="P:ReadOnlyDictionary`2.Keys">
            <summary>Gets a collection containing the keys in the
            <see cref="T:ReadOnlyDictionary{TKey,TValue}"></see>.</summary>
            <value>A <see cref="T:System.Collections.Generic.Dictionary`2.KeyCollection"/> 
            containing the keys.</value>
            <returns>A
            <see cref="T:System.Collections.Generic.Dictionary`2.KeyCollection"/>
            containing the keys in the
            <see cref="T:System.Collections.Generic.Dictionary`2"></see>.
            </returns>
        </member>
        <member name="P:ReadOnlyDictionary`2.Values">
            <summary>
            Gets a collection containing the values of the
            <see cref="T:ReadOnlyDictionary`2"/>.
            </summary>
            <value>The collection of values.</value>
        </member>
        <member name="P:ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#IsReadOnly">
            <summary>Gets a value indicating whether the dictionary is read-only.
            This value will always be true.</summary>
        </member>
        <member name="P:ReadOnlyDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the dictionary
            is synchronized (thread safe).
            </summary>
        </member>
        <member name="P:ReadOnlyDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to dictionary.
            </summary>
        </member>
        <member name="P:ReadOnlyDictionary`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <returns>
            The value associated with the specified key. If the specified key
            is not found, a get operation throws a 
            <see cref="T:System.Collections.Generic.KeyNotFoundException" />,
            and a set operation creates a new element with the specified key.
            </returns>
            <param name="key">The key of the value to get or set.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the key is null.
            </exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            The property is retrieved and key does not exist in the collection.
            </exception>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.IDuplexRouterFactory">
            <summary>
            Declares the factory creating duplex router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouterFactory.CreateDuplexRouter">
            <summary>
            Creates the duplex router.
            </summary>
            <returns>duplex router</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2">
            <summary>
            Sender of typed messages.
            </summary>
            <typeparam name="_ResponseType">receives response messages of this type.</typeparam>
            <typeparam name="_RequestType">sends messages of this type.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.SendRequestMessage(`1)">
            <summary>
            Sends message of specified type.
            </summary>
            <param name="message"></param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.ConnectionOpened">
            <summary>
            The event is raised when the connection with the receiver is open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.ConnectionClosed">
            <summary>
            The event is raised when the connection with the receiver is closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.ResponseReceived">
            <summary>
            The event is invoked when a response message was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory">
            <summary>
            Factory for creating channel wrapper and unwrapper.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.#ctor">
            <summary>
            Constructs the channel wrapper factory with XmlStringSerializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the channel wrapper factory with specified serializer.
            </summary>
            <param name="serializer">serializer used for wrapping channels with data messages.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateDuplexChannelWrapper">
            <summary>
            Creates duplex channel wrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateDuplexChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates duplex channel unwrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.NamespaceDoc">
            <summary>
            Communication via Websockets.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer">
            <summary>
            TCP policy server needed for the communication with Silverlight applications.
            </summary>
            <remarks>
            The policy server is required by Silverlight for the communication via HTTP or TCP.
            (See also <see cref="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer"/>.)
            <br/><br/>
            The TCP policy server is a special service listening on the port 943 (by default for all Ip adresses).
            When it receives &lt;policy-file-request/&gt; request, it returns the content of the policy file.
            <br/><br/>
            Silverlight automatically uses this service before the TCP connection is created.
            If a Silverlight application wants to open the TCP connection,
            Silverlight first sends the request on the port 943 and expects the policy file.
            If the policy server is not there or the content of the policy file does not allow
            the communication, the Tcp connection is not created.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer.#ctor">
            <summary>
            Constructs the TCP policy server providing the policy file on the port 943 for all IP addresses.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer.#ctor(System.Net.IPAddress)">
            <summary>
            Constructs the TCP policy server for the specified IP address.
            </summary>
            <param name="ipAddress"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer.StartPolicyServer">
            <summary>
            Starts the policy server.
            </summary>
            <remarks>
            It starts the thread listening to requests on port 943 and responding the policy XML.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer.StopPolicyServer">
            <summary>
            Stops the policy server.
            </summary>
            <remarks>
            It stops the listening and responding for requests.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer.GetSilverlightDefaultPolicyXml">
            <summary>
            Returns the default xml policy file.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer.PolicyXml">
            <summary>
            Gets or sets the policy xml.
            </summary>
            <remarks>
            When the class is instantiated, the default policy XML is set.
            The default policy XML allows the communication with everybody on all Silverlight ports 4502 - 4532.
            <br/>
            You can use this property to set your own policy file if needed.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer.IsListening">
            <summary>
            Returns true, if this instance of policy server is listening to requests.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.HostListenerBase">
            <summary>
            Base class representing listeners listening to the particular IP address and port and
            forwarding the processing according to path to the correct handler.
            E.g. http://127.0.0.1:9055/aaa/bbb/.
            The Host listener is listening to 127.0.0.1:9055. Then it parse out the path /aaa/bbb/ and
            forwards the request to the handler responsible for this path.
            </summary>
            <remarks>
            This is used for the implementation of http and websocket listeners.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpListenerProvider.DoListening">
            <summary>
            Loop for the main listening thread.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.RsaDigitalSignatureSerializer">
            <summary>
            Serializer digitaly signing data.
            </summary>
            <remarks>
            Serialization:
            <ol>
            <li>Incoming data is serialized by underlying serializer (e.g. XmlStringSerializer)</li>
            <li>SHA1 hash is calculated from the serialized data.</li>
            <li>The hash is encrypted with RSA using the private key.</li>
            <li>The serialized data consists of serialized data, encoded hash (signature) and public certificate of the signer.</li>
            </ol>
            Deserialization:
            <ol>
            <li>The public certificate is taken from serialized data and verified. (you can provide your own verification)</li>
            <li>SHA1 hash is calculated from serialized data.</li>
            <li>Encrypted hash (signature) is decrypted by public key taken from the certificate.</li>
            <li>If the decrypted hash is same as calculated one the data is ok.</li>
            <li>Data is deserialized by the underlying serializer and returned.</li>
            </ol>
            <example>
            Example shows how to serialize/deserialize data using digital signature.
            <code>
            // Get the certificate containing public and private keys. E.g. from the file.
            X509Certificate2 aSignerCertificate = new X509Certificate2("c:/MyCertificate.pfx", "mypassword");
            
            // Create the serializer.
            RsaDigitalSignatureSerializer aSerializer = new RsaDigitalSignatureSerializer(aSignerCertificate);
            
            // Serialize data.
            // (serialized data will contain digital signature and signer's public certificate)
            object aSerializedData = aSerializer.Serialize&lt;string&gt;("Hello world.");
            
            // Deserialize data.
            string aDeserializedData = aSerializer.Deserialize&lt;string&gt;(aSerializedData);
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RsaDigitalSignatureSerializer.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Constructs the serializer with default parameters.
            </summary>
            <remarks>
            It uses XmlStringSerializer as the underlying serializer and it uses default X509Certificate2.Verify() method to verify
            the public certificate.
            </remarks>
            <param name="signerCertificate">signer certificate containing public and also private part.
            The key from the private part is used to sign data during the serialization.<br/>
            The public certificate is attached to serialized data.<br/>
            If the parameter signerCertificate is null then the serializer can be used only for deserialization.
            </param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RsaDigitalSignatureSerializer.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2,System.Func{System.Security.Cryptography.X509Certificates.X509Certificate2,System.Boolean},Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer with custom parameters.
            </summary>
            <param name="signerCertificate">signer certificate containing public and also private part.
            The key from the private part is used to sign data during the serialization.<br/>
            The public certificate is attached to serialized data.<br/>
            If the parameter certificate is null then the serializer can be used only for deserialization.
            </param>
            <param name="verifySignerCertificate">callback to verify the certificate. If null then default X509Certificate2.Verify() is used.</param>
            <param name="underlyingSerializer">underlying serializer that will be used to serialize/deserialize data</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RsaDigitalSignatureSerializer.Serialize``1(``0)">
            <summary>
            Serializes data.
            </summary>
            <typeparam name="_T">data type to be serialized</typeparam>
            <param name="dataToSerialize">data to be serialized</param>
            <returns>serialized data</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RsaDigitalSignatureSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data.
            </summary>
            <typeparam name="_T">data type to be deserialized</typeparam>
            <param name="serializedData">serialized data</param>
            <returns>deserialized data type</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.LoadBalancer.RequestReceiverRemovedEventArgs">
            <summary>
            Event which is invoked when the receiver is removed from the load balancer pool.
            </summary>
            <remarks>
            The request receiver is removed from the pool if the load balancer cannot open the connection with the receiver.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.RequestReceiverRemovedEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event.
            </summary>
            <param name="channelId"></param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.LoadBalancer.RequestReceiverRemovedEventArgs.ChannelId">
            <summary>
            Returns the address of the request receiver.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase">
            <summary>
            The abstract class implementing the interface for attaching multiple input channels.
            The class also contains functionality to send (forward) messages via duplex output channels - the duplex input channel
            from the message is forwarded is remembered.
            The duplex output channels used for forwarding are not attached but dynamically created as they are needed.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.CloseConnections(System.Collections.Generic.IEnumerable{Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TConnection})">
            <summary>
            Closes given connections with client duplex output channel.
            </summary>
            <param name="connections"></param>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TConnection">
            <summary>
            Represents the connection between the duplex input channel and the duplex output channel.
            So when the response from the duplex output channel is received it can be forwarded to attached the
            duplex input channel with the correct response receiver id.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TDuplexInputChannelContext">
            <summary>
            The context of the duplex input channel consists of the attached duplex input channel and
            it also can contain the list of duplex output channels used to forward the message.
            E.g. The DuplexDispatcher receives the message from the attached duplex input channel and then forwards
            it to all duplex output channels.
            E.g. The DuplexChannelWrapper receives the message from the attached duplex input channel then wrapps
            the message and sends it via the duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher">
            <summary>
            Dispatcher.
            </summary>
            <remarks>
            The duplex dispatcher has attached more duplex input channels and uses more duplex output channels.<br/>
            When it receives some message via the duplex input channel it forwards the message to all duplex output channels.<br/>
            The duplex dispatcher allows the bidirectional communication. It means, receivers to whom the message was forwarded can
            send back response messages. Therefore, the sender can get response messages from all receivers.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.AddDuplexOutputChannel(System.String)">
            <summary>
            Adds the duplex output channel id to the dispatcher. The dispatcher will then start to forward
            the incoming messages also to this channel.
            </summary>
            <param name="channelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.RemoveDuplexOutputChannel(System.String)">
            <summary>
            Removes the duplex output channel from the dispatcher.
            </summary>
            <param name="channelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.RemoveAllDuplexOutputChannels">
            <summary>
            Removes all duplex output channels from the dispatcher.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.GetAssociatedResponseReceiverId(System.String)">
            <summary>
            Returns response receiver id of the client connected to the dispatcher.
            </summary>
            <param name="responseReceiverId">responseRecieverId after dispatching</param>
            <returns>responseReceiverId of the client connected to the dispatcher. Returns null if it does not exist.</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.NamespaceDoc">
            <summary>
            Publish-subscribe scenarios (clients can subscribe for notification messages).
            </summary>
            <remarks>
            The broker is intended for publish-subscribe scenarios. Clients can use the broker to publish notification messages or
            to subscribe for notification messages.<br/>
            The broker works like this:<br/>
            The client has some event that wants to notify to everybody who is interested. It sends the message to the broker.
            The broker receives the message and forwards it to everybody who is subscribed for such event.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.NamespaceDoc">
            <summary>
            Encoding/decoding the communication between communicating channels.
            </summary>
            <remarks>
            The protocol formatter is responsible for encoding these three types of messages that are used
            for the interaction between output and input channel. 
            <ul>
            <li><b>Open Connection</b> - Output channel sends this message to the input channel when it opens the connection.</li>
            <li><b>Close Connection</b> - Output channel sends this message to the input channel when it closes the connection.
                                   The input channel sends this message to the output channel when it disconnects the output channel. </li>
            <li><b>Message</b> - output channel uses this message when it sends a data message (request message) to the input channel.
                          The input channel sends this message when it sends a data response message back to the output channel.</li>
            </ul>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter">
            <summary>
            Implements encoding/decoding of low-level messages into eneter format.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeOpenConnectionMessage(System.String)">
            <summary>
            Encodes open connection request.
            </summary>
            <param name="responseReceiverId">client id</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeOpenConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Encodes 'open connection' message directly to the stream.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="outputSream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeCloseConnectionMessage(System.String)">
            <summary>
            Encodes close connection request.
            </summary>
            <param name="responseReceiverId">client id</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeCloseConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Encodes 'close connection' message directly to the stream.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="outputSream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeMessage(System.String,System.Object)">
            <summary>
            Encodes a message or a response message.
            </summary>
            <param name="responseReceiverId">client id</param>
            <param name="message">the serialized content of the message</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeMessage(System.String,System.Object,System.IO.Stream)">
            <summary>
            Encodes 'request message' or 'response message' directly to the stream.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="message"></param>
            <param name="outputSream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.DecodeMessage(System.IO.Stream)">
            <summary>
            Decodes a message or a response message from the stream.
            </summary>
            <param name="readStream">stream containing the low-level message</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.DecodeMessage(System.Byte[])">
            <summary>
            Decodes a message or a response message from the byte[].
            </summary>
            <param name="readMessage">source of the low-level message</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.NamespaceDoc">
            <summary>
            Sending and receiving text messages.
            </summary>
            <example>
            For more details see example:
            <ul>
                <li><see cref="T:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory"/> - sending and receiving text messages.</li>
            </ul>
            </example>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory">
            <summary>
            Implements the factory to create duplex string message sender and receiver.
            </summary>
            <remarks>
            <example>
            Client sending and receiving text messages.
            <code>
            // Create string message sender.
            IDuplexStringMessagesFactory aSenderFactory = new DuplexStringMessagesFactory();
            IDuplexStringMessageSender aSender = aSenderFactory.CreateDuplexStringMessageSender();
            
            // Subscribe to receive responses.
            aSender.ResponseReceived += OnResponseReceived;
            
            // Attach duplex output channel and be able to send messages and receive responses.
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:9876/");
            aSender.AttachDuplexOutputChannel(anOutputChannel);
            
            // Send a message.
            aSender.SendMessage("Hello.");
            
            ...
            
            // Do not forget to detach the output channel e.g. before application stops.
            // It will release the thread listening to response messages.
            aSender.DetachDuplexOutputChannnel();
            
            </code>
            </example>
            <example>
            Service sending and receiving text messages.
            <code>
            // Create string message receiver.
            IDuplexStringMessagesFactory aReceiverFactory = new DuplexStringMessagesFactory();
            IDuplexStringMessageReceiver aReceiver = aReceiverFactory.CreateDuplexStringMessageReciever();
            
            // Subscribe to receive responses.
            aReceiver.RequestReceived += OnRequestReceived;
            
            // Attach duplex input channel and start listening.
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:9876/");
            aReceiver.AttachDuplexInputChannel(anInputChannel);
            
            ...
            
            // Stop listening.
            aReceiver.DetachDuplexInputChannel();
            
            ...
            
            void OnRequestReceived(object sender, StringRequestReceivedEventArgs e)
            {
                IDuplexStringMessageReceiver aReceiver = (IDuplexStringMessageReceiver) sender;
                
                // Send back the response message.
                aReceiver.SendResponseMessage(e.ResponseReceiverId, "Hi, I am here.");
            }
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory">
            <summary>
            Creates sender and receiver for text messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory.CreateDuplexStringMessageSender">
            <summary>
            Creates message sender.
            </summary>
            <returns>string message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory.CreateDuplexStringMessageReceiver">
            <summary>
            Creates message receiver.
            </summary>
            <returns>string message receiver</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory.CreateDuplexStringMessageSender">
            <summary>
            Creates the duplex string message sender.
            </summary>
            <returns>duplex string message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory.CreateDuplexStringMessageReceiver">
            <summary>
            Creates the duplex string message receiver.
            </summary>
            <returns>duplex string message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory">
            <summary>
            Implements the messaging system delivering messages via HTTP.
            </summary>
            <remarks>
            It creates the communication channels using HTTP for sending and receiving messages.
            The channel id must be a valid URI address. E.g.: http://127.0.0.1/something/ or https://127.0.0.1/something/. <br/>
            Because HTTP is request-response based protocol, it does not keep the connection open.
            Therefore, for the bidirectional communication used by duplex channels, the polling mechanism is used.
            The duplex output channel regularly polls for response messages and the duplex input channel constantly measures the inactivity time
            to recognize whether the duplex output channel is still connected.<br/><br/>
            Notice, to start listening via input channel (or duplex input channel), the application must be executed with sufficient rights.
            Otherwise the exception will be thrown.<br/>
            Also notice, Silverlight and Windows Phone 7 do not support listening to HTTP requests.
            Therefore, only sending of messages (and receiving response messages) is possible in these platforms.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory that will create channels with default settings. The polling
            frequency will be 500 ms and the inactivity timeout will be 10 minutes.
            </summary>
            <remarks>
            The polling frequency and the inactivity time are used only by duplex channels.
            The polling frequency specifies how often the duplex output channel checks if there are pending response messages.
            The inactivity time is measured by the duplex input channel and specifies the maximum time, the duplex output channel
            does not have to poll for messages.
            If the inactivity time is exceeded, considers the duplex output channel as disconnected.
            <br/><br/>
            In case of Silverlight or Windows Phone 7, the response messages are recieved in the main Silverlight thread.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs the factory that will create channel with specified settings.
            </summary>
            <remarks>
            The polling frequency and the inactivity time are used only by duplex channels.
            The polling frequency specifies how often the duplex output channel checks if there are pending response messages.
            The inactivity time is measured by the duplex input channel and specifies the maximum time, the duplex output channel
            does not have to poll for messages.
            If the inactivity time is exceeded, considers the duplex output channel as disconnected.
            </remarks>
            <param name="pollingFrequency">how often the duplex output channel polls for the pending response messages</param>
            <param name="inactivityTimeout">maximum time (measured by duplex input channel), the duplex output channel does not have to poll
            for response messages. If the time is exceeded, the duplex output channel is considered as disconnected.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor(System.Int32,System.Int32,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter{System.Byte[]})">
            <summary>
            Constructs the factory that will create channel with specified settings.
            </summary>
            <remarks>
            The polling frequency and the inactivity time are used only by duplex channels.
            The polling frequency specifies how often the duplex output channel checks if there are pending response messages.
            The inactivity time is measured by the duplex input channel and specifies the maximum time, the duplex output channel
            does not have to poll for messages.
            If the inactivity time is exceeded, considers the duplex output channel as disconnected.
            </remarks>
            <param name="pollingFrequency">how often the duplex output channel polls for the pending response messages</param>
            <param name="inactivityTimeout">maximum time (measured by duplex input channel), the duplex output channel does not have to poll
            for response messages. If the time is exceeded, the duplex output channel is considered as disconnected.</param>
            <param name="protocolFormatter">formatter for low-level messages between duplex output channel and duplex input channel</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using HTTP.
            The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid address of the receiver. e.g. 127.0.0.1:8090</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using HTTP.
            The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid address of the receiver. e.g. 127.0.0.1:8090</param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using HTTP.
            The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/
            The method is not supported in Silverlight and Windows Phone 7.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">channel id specifying the address the duplex input channel listens to.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.myPollingFrequency">
            <summary>
            Defines how often the client poll the server for response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.InputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex input channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed by one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.RpcFactory">
            <summary>
            Creates services and clients that can communicate using RPC (Remote Procedure Calls).
            </summary>
            <remarks>
            RPC is the communication scenario where an application (typically client) executes a method in another application (typically service). 
            RpcFactory provides methods to instantiate RpcService and RpcClient objects.
            
            RpcService acts as a stub which provides the communication functionality allowing the service to be reached from outside.
            RpcClient acts as a proxy which provides the communication functionality allowing the client to call remote methods in the service.
            
            The following example shows simple client-service communication using RPC.
            
            <example>
            Implementing the service:
            <code>
            public interface IHello
            {
                event EventHandler&lt;MyEventArgs&gt; SomethingHappned;
                int Calculate(int a, int b);
            }
            
            public class HelloService : IHello
            {
                public event EventHandler&lt;MyEventArgs&gt; SomethingHappned;
            
                int Calculate(int a, int b)
                {
                    return a + b;
                }
            
                public void RaiseEvent()
                {
                    if (SomethingHappned != null)
                    {
                        SomethingHappned(this, new MyEventArgs());
                    }
                }
            }
            
            
            class Program
            {
                static void Main(string[] args)
                {
                    // Instantiate service.
                    HelloService aHelloService = new HelloService();
                    IRpcFactory anRpcFactory = new RpcFactory();
                    IRpcService&lt;IHello&gt; aService = anRpcFactory.CreateService&lt;ICalculator&gt;(aHelloService);
            
                    // Attach input channel and start listening.
                    IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
                    IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:8045/");
                    aService.AttachDuplexInputChannel(anInputChannel);
            
                    Console.WriteLine("Hello service started. Press ENTER to stop.");
                    Console.ReadLine();
            
                    // Detach input channel and stop listening.
                    // Note: it releases the listening thread.
                    aService.DetachDuplexInputChannel();
                }
            }
            </code>
            </example>
            
            <example>
            Using service from the client.
            <code>
            // Get the service proxy for the interface.
            IRpcFactory anRpcFactory = new RpcFactory();
            myRpcClient = anRpcFactory.CreateClient&lt;IHello&gt;();
            
            // Attach output channel and be able to communicate.
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:8045/");
            myRpcClient.AttachDuplexOutputChannel(anOutputChannel);
            
            // Call service.
            IHello aServiceProxy = myRpcClient.Proxy;
            int aResult = aServiceProxy.Calculate(10, 20);
            </code>
            </example>
            
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.IRpcFactory">
            <summary>
            Creates services and clients that can communicate using Remote Procedure Calls.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.IRpcFactory.CreateClient``1">
            <summary>
            Creates RPC client for the given interface.
            </summary>
            <typeparam name="TServiceInterface">service interface type.</typeparam>
            <returns>RpcClient instance</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.IRpcFactory.CreateSingleInstanceService``1(``0)">
            <summary>
            Creates single-instance RPC service for the given interface.
            </summary>
            <remarks>
            Single-instance means that there is one instance of the service shared by all clients.
            </remarks>
            <typeparam name="TServiceInterface">service interface type</typeparam>
            <param name="service">instance implementing the given service interface</param>
            <returns>RpcService instance.</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.IRpcFactory.CreatePerClientInstanceService``1(System.Func{``0})">
            <summary>
            Creates per-client-instance RPC service for the given interface.
            </summary>
            <remarks>
            Per-client-instance means that for each connected client is created a separate instace of the service.
            </remarks>
            <typeparam name="TServiceInterface">service interface type</typeparam>
            <param name="serviceFactoryMethod">factory method used to create the service instance when the client is connected</param>
            
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.RpcFactory.#ctor">
            <summary>
            Constructs RpcFactory with default <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.RpcFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs RpcFactory with specified serializer.
            </summary>
            <remarks>
            List of serializers provided by Eneter: <see cref="N:Eneter.Messaging.DataProcessing.Serializing"/>.
            </remarks>
            <param name="serializer"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.RpcFactory.CreateClient``1">
            <summary>
            Creates RPC client for the given interface.
            </summary>
            <typeparam name="TServiceInterface">service interface type</typeparam>
            <returns>RpcClient instance</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.RpcFactory.CreateSingleInstanceService``1(``0)">
            <summary>
            Creates single-instance RPC service for the given interface.
            </summary>
            <remarks>
            Single-instance means that there is one instance of the service which shared by all clients.
            </remarks>
            <typeparam name="TServiceInterface">service interface type</typeparam>
            <param name="service">instance implementing the given service interface</param>
            <returns>RpcService instance.</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.RpcFactory.CreatePerClientInstanceService``1(System.Func{``0})">
            <summary>
            Creates per-client-instance RPC service for the given interface.
            </summary>
            <remarks>
            Per-client-instance means that for each connected client is created a separate instace of the service.
            </remarks>
            <typeparam name="TServiceInterface">service interface type</typeparam>
            <param name="serviceFactoryMethod">factory method used to create the service instance when the client is connected</param>
            
            <returns></returns>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcFactory.Serializer">
            <summary>
            Gets/sets serializer used for serializing messages between RpcClient and RpcService.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcFactory.RpcClientThreading">
            <summary>
            Gets/sets threading mechanism used for invoking events (if RPC interface has some) and ConnectionOpened and ConnectionClosed events.
            </summary>
            <remarks>
            Default setting is that events are routed one by one via a working thread.<br/>
            It is recomended not to set the same threading mode for the attached output channel because a deadlock can occur when
            a remote procedure is called (e.g. if a return value from a remote method is routed to the same thread as is currently waiting for that return value the deadlock occurs).<br/>
            <br/>
            Note: The threading mode for the RPC service is defined by the threading mode of attached duplex input channel.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcFactory.RpcTimeout">
            <summary>
            Gets/sets timeout which specifies until when a call to a remote method must return.
            </summary>
            <remarks>
            Default value is TimeSpan.FromMilliseconds(-1) what is the infinite time. 
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.GZipSerializer">
            <summary>
            Serializer compressing and decompressing data.
            </summary>
            <remarks>
            The serializer internally uses GZipStream to compress and decompress data.
            <example>
            Example shows how to serialize data.
            <code>
            // Creat the serializer.
            GZipSerializer aSerializer = new GZipSerializer();
            
            // Create some data to be serialized.
            MyData aData = new MyData();
            ...
            
            // Serialize data. Serialized data will be compressed.
            object aSerializedData = aSerializer.Serialize&lt;MyData&gt;(aData);
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.GZipSerializer.#ctor">
            <summary>
            Constructs the serializer with XmlStringSerializer as the underlying serializer.
            </summary>
            <remarks>
            The serializer uses the underlying serializer to serialize data before the compression.
            It also uses the underlying serializer to deserialize decompressed data.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.GZipSerializer.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer with the given underlying serializer.
            </summary>
            <remarks>
            The serializer uses the underlying serializer to serialize data before the compression.
            It also uses the underlying serializer to deserialize decompressed data.
            </remarks>
            <param name="underlyingSerializer">underlying serializer</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.GZipSerializer.Serialize``1(``0)">
            <summary>
            Serializes the given data with using the compression.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.GZipSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes compressed data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Compressed data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory">
            <summary>
            Implements factory to create the dispatcher.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcherFactory">
            <summary>
            Creates the dispatcher.
            </summary>
            <remarks>
            The dispatcher sends messages to all duplex output channels and also can route back response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcherFactory.CreateDuplexDispatcher">
            <summary>
            Creates the dispatcher.
            </summary>
            <returns>duplex dispatcher</returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the duplex dispatcher factory.
            </summary>
            <param name="duplexOutputChannelsFactory">
            the messaging system factory used to create duplex output channels
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory.CreateDuplexDispatcher">
            <summary>
            Creates the duplex dispatcher.
            </summary>
            <returns>duplex dispatcher</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.NamespaceDoc">
            <summary>
            Reducing communication via multiple channels into one channel.
            </summary>
            <remarks>
            The channel wrapper and unwrapper are components allowing to send/receive different types of messages via one channel.
            E.g. to send and receive multiple types of request messages via one IP address and port.
            <example>
            Simple service using the channel unwrapper to receive all request messages via one IP address and port.
            <code>
            namespace ServerCalculator2
            {
                // Input data for calculator requests
                public class CalculatorInputData
                {
                    public double Number1 { get; set; }
                    public double Number2 { get; set; }
                }
            
                // Output result from the calculator
                public class CalculatorOutputData
                {
                    public double Result { get; set; }
                }
            
                internal class Calculator
                {
                    public Calculator()
                    {
                        // Internal messaging used for messaging between channel unwrapper
                        // and typed message receivers.
                        // We want that requests do not block each other. So every request will be processed in its own thread.
                        IMessagingSystemFactory anInternalMessaging = new ThreadPoolMessagingSystemFactory();
            
                        // All messages are received via one channel. So we must provide "unwrapper" forwarding incoming messages
                        // to correct receivers.
                        IChannelWrapperFactory aChannelWrapperFactory = new ChannelWrapperFactory();
                        myDuplexChannelUnwrapper = aChannelWrapperFactory.CreateDuplexChannelUnwrapper(anInternalMessaging);
            
                        // To connect receivers and the unwrapper with duplex channels we can use the following helper class.
                        IConnectionProviderFactory aConnectionProviderFactory = new ConnectionProviderFactory();
                        IConnectionProvider aConnectionProvider = aConnectionProviderFactory.CreateConnectionProvider(anInternalMessaging);
            
                        // Factory to create message receivers.
                        IDuplexTypedMessagesFactory aMessageReceiverFactory = new DuplexTypedMessagesFactory();
                        
                        // Create receiver to sum two numbers.
                        mySumReceiver = aMessageReceiverFactory.CreateDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        mySumReceiver.MessageReceived += SumCmd; // attach method handling the request
                        aConnectionProvider.Attach(mySumReceiver, "Sum"); // attach the input channel to get messages from unwrapper
            
                        // Receiver to subtract two numbers.
                        mySubtractReceiver = aMessageReceiverFactory.CreateDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        mySubtractReceiver.MessageReceived += SubCmd; // attach method handling the request
                        aConnectionProvider.Attach(mySubtractReceiver, "Sub"); // attach the input channel to get messages from unwrapper
            
                        // Receiver for multiply two numbers.
                        myMultiplyReceiver = aMessageReceiverFactory.CreateDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        myMultiplyReceiver.MessageReceived += MulCmd; // attach method handling the request
                        aConnectionProvider.Attach(myMultiplyReceiver, "Mul"); // attach the input channel to get messages from unwrapper
            
                        // Receiver for divide two numbers.
                        myDivideReceiver = aMessageReceiverFactory.CreateDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        myDivideReceiver.MessageReceived += DivCmd; // attach method handling the request
                        aConnectionProvider.Attach(myDivideReceiver, "Div"); // attach the input channel to get messages from unwrapper
                    }
            
            
                    public void Start()
                    {
                        // We use TCP based messaging.
                        IMessagingSystemFactory aServiceMessagingSystem = new TcpMessagingSystemFactory();
                        IDuplexInputChannel anInputChannel = aServiceMessagingSystem.CreateDuplexInputChannel("tcp://127.0.0.1:8091/");
            
                        // Attach the input channel to the unwrapper and start to listening.
                        myDuplexChannelUnwrapper.AttachDuplexInputChannel(anInputChannel);
                    }
            
                    public void Stop()
                    {
                        // Detach the input channel from the unwrapper and stop listening.
                        // Note: It releases listening threads.
                        myDuplexChannelUnwrapper.DetachDuplexInputChannel();
                    }
            
                    // It is called when a request to sum two numbers was received.
                    private void SumCmd(object sender, TypedRequestReceivedEventArgs&lt;CalculatorInputData&gt; e)
                    {
                        // Get input data.
                        CalculatorInputData anInputData = e.RequestMessage;
            
                        // Calculate output result.
                        CalculatorOutputData aReturn = new CalculatorOutputData();
                        aReturn.Result = anInputData.Number1 + anInputData.Number2;
            
                        Console.WriteLine("{0} + {1} = {2}", anInputData.Number1, anInputData.Number2, aReturn.Result);
            
                        // Response result to the client.
                        mySumReceiver.SendResponseMessage(e.ResponseReceiverId, aReturn);
                    }
            
                    // It is called when a request to subtract two numbers was received.
                    private void SubCmd(object sender, TypedRequestReceivedEventArgs&lt;CalculatorInputData&gt; e)
                    {
                        // Get input data.
                        CalculatorInputData anInputData = e.RequestMessage;
            
                        // Calculate output result.
                        CalculatorOutputData aReturn = new CalculatorOutputData();
                        aReturn.Result = anInputData.Number1 - anInputData.Number2;
            
                        Console.WriteLine("{0} - {1} = {2}", anInputData.Number1, anInputData.Number2, aReturn.Result);
            
                        // Response result to the client.
                        mySubtractReceiver.SendResponseMessage(e.ResponseReceiverId, aReturn);
                    }
                    
            
                    // It is called when a request to multiply two numbers was received.
                    private void MulCmd(object sender, TypedRequestReceivedEventArgs&lt;CalculatorInputData&gt; e)
                    {
                        // Get input data.
                        CalculatorInputData anInputData = e.RequestMessage;
            
                        // Calculate output result.
                        CalculatorOutputData aReturn = new CalculatorOutputData();
                        aReturn.Result = anInputData.Number1 * anInputData.Number2;
            
                        Console.WriteLine("{0} x {1} = {2}", anInputData.Number1, anInputData.Number2, aReturn.Result);
            
                        // Response result to the client.
                        myMultiplyReceiver.SendResponseMessage(e.ResponseReceiverId, aReturn);
                    }
            
                    // It is called when a request to divide two numbers was received.
                    private void DivCmd(object sender, TypedRequestReceivedEventArgs&lt;CalculatorInputData&gt; e)
                    {
                        // Get input data.
                        CalculatorInputData anInputData = e.RequestMessage;
            
                        // Calculate output result.
                        CalculatorOutputData aReturn = new CalculatorOutputData();
                        aReturn.Result = anInputData.Number1 / anInputData.Number2;
            
                        Console.WriteLine("{0} / {1} = {2}", anInputData.Number1, anInputData.Number2, aReturn.Result);
            
                        // Response result to the client.
                        myDivideReceiver.SendResponseMessage(e.ResponseReceiverId, aReturn);
                    }
                    
            
                    // Unwrapps messages from the input channel and forwards them
                    // to corresponding output channels.
                    private IDuplexChannelUnwrapper myDuplexChannelUnwrapper;
            
                    // Paticular services listening to requests which will be forwarded from
                    // the channel unwrapper.
                    private IDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt; mySumReceiver;
                    private IDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt; mySubtractReceiver;
                    private IDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt; myMultiplyReceiver;
                    private IDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt; myDivideReceiver;
                }
            }
            </code>
            </example>
            
            <example>
            Client using channel wrapper to send all request messages one IP address and port.
            <code>
            namespace CalculatorClient2
            {
                public partial class Form1 : Form
                {
                    // Input data for calculator requests
                    public class CalculatorInputData
                    {
                        public double Number1 { get; set; }
                        public double Number2 { get; set; }
                    }
            
                    // Output result from the calculator
                    public class CalculatorOutputData
                    {
                        public double Result { get; set; }
                    }
            
                    public Form1()
                    {
                        InitializeComponent();
            
                        // Internal messaging between message senders and channel wrapper.
                        IMessagingSystemFactory anInternalMessaging = new SynchronousMessagingSystemFactory();
            
                        // The service receives messages via one channel (i.e. it listens on one address).
                        // The incoming messages are unwrapped on the server side.
                        // Therefore the client must use wrapper to send messages via one channel.
                        IChannelWrapperFactory aChannelWrapperFactory = new ChannelWrapperFactory();
                        myDuplexChannelWrapper = aChannelWrapperFactory.CreateDuplexChannelWrapper();
            
            
                        // To connect message senders and the wrapper with duplex channels we can use the following helper class.
                        IConnectionProviderFactory aConnectionProviderFactory = new ConnectionProviderFactory();
                        IConnectionProvider aConnectionProvider = aConnectionProviderFactory.CreateConnectionProvider(anInternalMessaging);
            
                        
                        // Factory to create message senders.
                        // Sent messages will be serialized in Xml.
                        IDuplexTypedMessagesFactory aCommandsFactory = new DuplexTypedMessagesFactory();
            
                        // Sender to sum two numbers.
                        mySumSender = aCommandsFactory.CreateDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        mySumSender.ResponseReceived += OnResultResponse;
                        aConnectionProvider.Connect(myDuplexChannelWrapper, mySumSender, "Sum");
            
                        // Sender to subtract two numbers.
                        mySubSender = aCommandsFactory.CreateDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        mySubSender.ResponseReceived += OnResultResponse;
                        aConnectionProvider.Connect(myDuplexChannelWrapper, mySubSender, "Sub");
            
                        // Sender to multiply two numbers.
                        myMulSender = aCommandsFactory.CreateDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        myMulSender.ResponseReceived += OnResultResponse;
                        aConnectionProvider.Connect(myDuplexChannelWrapper, myMulSender, "Mul");
            
                        // Sender to divide two numbers.
                        myDivSender = aCommandsFactory.CreateDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        myDivSender.ResponseReceived += OnResultResponse;
                        aConnectionProvider.Connect(myDuplexChannelWrapper, myDivSender, "Div");
            
                        // We use Tcp for the communication.
                        IMessagingSystemFactory aTcpMessagingSystem = new TcpMessagingSystemFactory();
            
                        // Create output channel to send requests to the service.
                        IDuplexOutputChannel anOutputChannel = aTcpMessagingSystem.CreateDuplexOutputChannel("tcp://127.0.0.1:8091/");
            
                        // Attach the output channel to the wrapper - so that we are able to send messages
                        // and receive response messages.
                        // Note: The service has the coresponding unwrapper.
                        myDuplexChannelWrapper.AttachDuplexOutputChannel(anOutputChannel);
                    }
            
                    private void Form1_FormClosed(object sender, FormClosedEventArgs e)
                    {
                        // Stop listening by detaching the input channel.
                        myDuplexChannelWrapper.DetachDuplexInputChannel();
                    }
            
            
                    private void OnResultResponse(object sender, TypedResponseReceivedEventArgs&lt;CalculatorOutputData&gt; e)
                    {
                        // If everything is ok then display the result.
                        if (e.ReceivingError == null)
                        {
                            // The response does not come in main UI thread.
                            // Therefore we must transfer it to the main UI thread.
                            InvokeInUIThread(() =&gt; ResultLabel.Text = e.ResponseMessage.Result.ToString() );
                        }
                    }
            
                    private void CalculateButton_Click(object sender, EventArgs e)
                    {
                        SendRequestMessage(mySumSender);
                    }
                     
                    private void SubtractButton_Click(object sender, EventArgs e)
                    {
                        SendRequestMessage(mySubSender);
                    }
            
                    private void MultiplyButton_Click(object sender, EventArgs e)
                    {
                        SendRequestMessage(myMulSender);
                    }
            
                    private void DivideButton_Click(object sender, EventArgs e)
                    {
                        SendRequestMessage(myDivSender);
                    }
            
                    private void SendRequestMessage(IDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt; sender)
                    {
                        // Prepare input data for the calculator.
                        CalculatorInputData anInputForCalculator = new CalculatorInputData();
                        anInputForCalculator.Number1 = double.Parse(Number1TextBox.Text);
                        anInputForCalculator.Number2 = double.Parse(Number2TextBox.Text);
            
                        // Send the request message.
                        sender.SendRequestMessage(anInputForCalculator);
                    }
            
                    // Helper method to invoke UI always in the correct thread.
                    private void InvokeInUIThread(Action action)
                    {
                        if (InvokeRequired)
                        {
                            Invoke(action);
                        }
                        else
                        {
                            action.Invoke();
                        }
                    }
            
                    // Wraps requests into one output channel.
                    // The service side listens to one address and uses unwrapper to unwrap
                    // messages and send them to correct receivers.
                    private IDuplexChannelWrapper myDuplexChannelWrapper;
            
                    // Message senders.
                    private IDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt; mySumSender;
                    private IDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt; mySubSender;
                    private IDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt; myMulSender;
                    private IDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt; myDivSender;
                }
            }
            </code>
            </example>
            
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.NamespaceDoc">
            <summary>
            Synchronous communication within one process (like a synchronous local call).
            </summary>
            <remarks>
            This messaging system transfers messages synchronously in the context of the calling thread.
            Therefore the calling thread is blocked until the message is delivered and processed.
            However, the notification events (e.g. connection opened, ...) can come in a different thread.
            The messaging system is very fast and is suitable to deliver messages locally between internal communication components.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs">
            <summary>
            Event argument representing the response receiver on the service site.
            </summary>
            <remarks>
            This event argument is typically used e.g. when the client opened/closed connection. 
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs.#ctor(System.String,System.String)">
            <summary>
            Constructs the event argument.
            </summary>
            <param name="responseReceiverId">Unique logical id identifying the receiver of response messages.</param>
            <param name="senderAddress">Address where the sender of the request message is located. (e.g. IP address of the client)<br/>
            Can be empty string if not applicable in used messaging.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs.ResponseReceiverId">
            <summary>
            Returns the unique logical id identifying the receiver of response messages.
            </summary>
            <remarks>
            This id identifies who receives the response message on the client side.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs.SenderAddress">
            <summary>
            Returns the address where the sender of the request message is located. (e.g. IP address of the client).
            It can be empty string if not applicable for used messaging.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs">
            <summary>
            Event argument used to notify that duplex input channel received a message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs">
            <summary>
            Event argument containing parameters of the communication.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructs the event argument.
            </summary>
            <param name="channelId">Identifies the receiver of request messages. (e.g. tcp://127.0.0.1:8090/)</param>
            <param name="responseReceiverId">Unique logical id identifying the receiver of response messages.</param>
            <param name="senderAddress">Address where the sender of the request message is located. (e.g. IP address of the client)<br/>
            Can be empty string if not applicable in used messaging.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.ChannelId">
            <summary>
            Returns the channel id identifying the receiver of request messages. (e.g. tcp://127.0.0.1:8090/).
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.ResponseReceiverId">
            <summary>
            Returns the unique logical id identifying the receiver of response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.SenderAddress">
            <summary>
            Returns the address where the sender of the request message is located. (e.g. IP address of the client).
            It can be empty string if not applicable for used messaging.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs.#ctor(System.String,System.Object,System.String,System.String)">
            <summary>
            Constructs the event.
            </summary>
            <param name="channelId">Identifies the receiver of request messages. (e.g. tcp://127.0.0.1:8090/)</param>
            <param name="message">message</param>
            <param name="responseReceiverId">Unique logical id identifying the receiver of response messages.</param>
            <param name="senderAddress">Address where the sender of the request message is located. (e.g. IP address of the client)<br/>
            Can be empty string if not applicable in used messaging.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs.Message">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter">
            <summary>
            The helper allowing to observe the particular duplex output channel.
            If the channel is disconnected, it tries to reopen the connection.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel)">
            <summary>
            Constructs the reconnecter that tries to reconnect infinitely every second.
            </summary>
            <param name="duplexOutputChannel">observed duplex output channel</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel,System.TimeSpan,System.Int32)">
            <summary>
            Constructs the reconnecter from specified parameters.
            </summary>
            <param name="duplexOutputChannel">observed duplex output channel</param>
            <param name="reconnectFrequency">how often the reconnect attempt shall be performed (in case of the disconnection)</param>
            <param name="maxReconnectAttempts">max amounts of reconnect attempts. If exceeded, the ReconnectingFailed is invoked.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.EnableReconnecting">
            <summary>
            Enables the automatic reconnecting in case the disconnect is notified.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.DisableReconnecting">
            <summary>
            Disables the automatic reconnecting.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.ConnectionClosed">
            <summary>
            The event is invoked when the observed duplex output channel notified, that the connection was closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.ConnectionOpened">
            <summary>
            The event is invoked when the duplex output channel was reconnected.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.ReconnectingFailed">
            <summary>
            The event is invoked when the reopenning of the duplex output channel failed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.IsReconnectingEnabled">
            <summary>
            Returns true if the reconnecting is enabled.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.NamespaceDoc">
            <summary>
            Sending and receiving messages as typed data.
            </summary>
            E.g. you may want that the request message is type of YourRequest and the response message
            is type of YourResponse.
            <example>
            For more details see examples:
            <ul>
                <li><see cref="T:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory"/> - sending and receiving messages of declared type.</li>
                <li><see cref="T:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory"/> - sending and receiving messages of declared typed and receiving information
                    if the message was delivered or not.</li>
            </ul>
            </example>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessageIdEventArgs">
            <summary>
            Event arguments used for notification whether the message was delivered or not delivered.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessageIdEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event arguments.
            </summary>
            <param name="messageId">id of the message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessageIdEventArgs.MessageId">
            <summary>
            Returns id of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transferring messages via Named Pipes.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.NamespaceDoc">
            <summary>
            Receiving messages and events according to specified thread mode. 
            </summary>
            <remarks>
            Threading dispatching allows to specify in which threads received messages shall be received.  
            E.g. you can specify that events like messageReceived, connectionOpened, connectionClosed, ... will be raised in the main UI thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelWrapper">
            <summary>
            Duplex channel wrapper.
            </summary>
            <remarks>
            The duplex channel wrapper is listening to more duplex input channels. When it receives some message,
            it wraps the message and sends it via the only duplex output channel.
            On the other side the message is received by duplex channel unwrapper. The unwrapper unwraps the message
            and uses the duplex output channel to forward the message to the correct receiver.<br/>
            The receiver can also send the response message. Then it goes the same way back.<br/>
            Notice, the 'duplex channel wrapper' can communication only with 'duplex channel unwrapper'.
            It cannot communicate with one-way 'channel unwrapper'.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelWrapper.ConnectionOpened">
            <summary>
            Event raised when the connection with the service was open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelWrapper.ConnectionClosed">
            <summary>
            Event raised when the connection with the service was closed.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelWrapper.OnMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            The method is called when a message from the attached duplex input channel is received.
            The received message is wrapped and sent to the duplex output channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelWrapper.OnResponseMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            The method is called when a reponse message is received from the duplex output channel.
            The received response is unwrapped and sent as a response to the matching duplex input channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory">
            <summary>
            Declares the factory to create the broker and the broker client.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory.CreateBrokerClient">
            <summary>
            Creates the broker client.
            </summary>
            <remarks>
            The broker client is able to send messages to the broker (via attached duplex output channel).
            It also can subscribe for messages to receive notifications from the broker.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory.CreateBroker">
            <summary>
            Creates the broker.
            </summary>
            <remarks>
            The broker receives messages and forwards them to subscribers.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory">
            <summary>
            Messaging system delivering messages asynchronously (when a message is received a separate thread is invoked to process it).
            </summary>
            <remarks>
            The incoming messages are processed by multiple threads from the pool. When a message is received the thread
            from the pool is taken and the message is notified.
            Therefore messages come asynchronously in various threads.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory representing the messaging system.
            </summary>
            <remarks>
            Every instance of the synchronous messaging system factory represents one messaging system.
            It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the factory representing the messaging system.
            </summary>
            <remarks>
            Every instance of the synchronous messaging system factory represents one messaging system.
            It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </remarks>
            <param name="protocolFormatter">formatter used to encode low-level messages between channels</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the thread pool.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the thread pool.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using the thread pool.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">Identifies this duplex input channel.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.InputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex input channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed by one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.NamespaceDoc">
            <summary>
            Interfaces declaring output and input channel.
            </summary>
            <remarks>
            The messaging system is responsible for delivering messages from a sender to a receiver through communication channels.<br/>
            <br/>
            The messaging system provides the duplex output channel and the duplex input channel.
            The duplex output channel sends messages to the duplex input channel with the same channel id and can receive response messages.
            The duplex input channel receives messages and can send back response messages.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage">
            <summary>
            Internal message used by Eneter framework for reliable communication.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.#ctor">
            <summary>
            Default constructor for serializing purposes.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.#ctor(System.String)">
            <summary>
            Constructs the acknowledge message.
            Acknowledge confirms, the message was delivered.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.#ctor(System.String,System.Object)">
            <summary>
            Constructs the reliable message that contains the message to be sent.
            </summary>
            <param name="messageId"></param>
            <param name="message"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.MessageType">
            <summary>
            Type of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.MessageId">
            <summary>
            In case of the message type Message - unique id of the reliable message.
            In case of the message type Acknowledge - id of the message, that is acknowledged.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.Message">
            <summary>
            In case of the message type Message - the message that shall be sent reliably.
            In case of the message type Acknowledge - not used.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.EMessageType">
            <summary>
            Indicates the purpose of the message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.EMessageType.Message">
            <summary>
            The reliable message contains a message that shall be notified via the event.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.EMessageType.Acknowledge">
            <summary>
            The reliable message is the acknowledgement, that the message was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver">
            <summary>
            Receiver of text messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.SendResponseMessage(System.String,System.String)">
            <summary>
            Sends the response message back to the string message sender.
            </summary>
            <param name="responseReceiverId">identifies the string message sender that shall receive the response</param>
            <param name="responseMessage">response text message</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.RequestReceived">
            <summary>
            The event is raised when a text message is received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.ResponseReceiverConnected">
            <summary>
            The event is raised when a duplex string message sender opened the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.ResponseReceiverDisconnected">
            <summary>
            The event is raised when a duplex string message sender closed the connection.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.EBrokerRequest">
            <summary>
            Specifies the broker request.
            </summary>
            <remarks>
            The request for the broker is the message that is intended for the broker and not for the subscribers.
            This message is used by the broker client to subscribe and unsubscribe.
            </remarks>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.Subscribe">
            <summary>
            Request to subscribe exactly for the specified message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.SubscribeRegExp">
            <summary>
            Request to subscribe for message type ids that match with the regular expression.
            I.e. regular expression is used to identify what message types shall be notified
            to the client.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.Unsubscribe">
            <summary>
            Request to unsubscribe from exactly specified message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.UnsubscribeRegExp">
            <summary>
            Request to unsubscribe the regular expression.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.UnsubscribeAll">
            <summary>
            Request to unsubscribe all messages and regular expressions.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.Publish">
            <summary>
            Request to publish a message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.BrokerMessage">
            <summary>
            Internal message used between DuplexBroker and DuplexBrokerClient.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessage.#ctor">
            <summary>
            Default constructor used by a deserializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessage.#ctor(Eneter.Messaging.Nodes.Broker.EBrokerRequest,System.String[])">
            <summary>
            Constructs the message requesting the broker to subscribe or unsubscribe events.
            </summary>
            <param name="request">subscribing or unsubscribing</param>
            <param name="messageTypes">events to be subscribed or unsubscribed.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessage.#ctor(System.String,System.Object)">
            <summary>
            Constructs the broker message requesting the broker to publish an event.
            </summary>
            <param name="messageTypeId">message type that shall be published</param>
            <param name="message">serialized message to be published</param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessage.Request">
            <summary>
            Type of the request.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessage.MessageTypes">
            <summary>
            Array of message types.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessage.Message">
            <summary>
            Serialized message that shall be notified to subscribers.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouter">
            <summary>
            Declares the router providing a possibility to reconnect with a backup service in case of a disconnection.
            </summary>
            <remarks>
            The backup router is a component that forwards incoming messages to a connected service (receiver).
            In case the connection with the receiver is broken it takes the next service from the list and opens the new connection.
            If it is at the end of the list it starts from the beginning.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouter.AddReceiver(System.String)">
            <summary>
            Adds the service to the list.
            </summary>
            <param name="channelId">address of the service</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouter.AddReceivers(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Adds services to the list.
            </summary>
            <param name="channelIds">addresses of the service</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouter.RemoveReceiver(System.String)">
            <summary>
            Removes the service from the list. If there are connections to this receiver then they will be closed and redirected.
            </summary>
            <param name="channelId">address of the service</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouter.RemoveAllReceivers">
            <summary>
            Removes the service from the list. It will close all connections.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouter.ConnectionRedirected">
            <summary>
            The event is invoked when the connection was broken but it was successfully reopened with the next service from the list.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouter.AllRedirectionsFailed">
            <summary>
            The event is invoked when it failed to connect to all available receivers.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouter.AvailableReceivers">
            <summary>
            Returns all available receivers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouter.RemoveAllReceivers">
            <summary>
            Cleans the list with available receivers. Existing connections are not broken.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouter.OnResponseReceiverConnected(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs)">
            <summary>
            It is called when a client opens the connection to this backup router.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouter.OnResponseReceiverDisconnected(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs)">
            <summary>
            It is called when the client actively closed the connection with this backup router.
            It will close the associated connection with the service.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouter.OnRequestMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            It is called when a message is received from a client connected to this Backup Router.
            The message will be forwarded to the connected service.
            If the sending fails the connection is considered broken it will try to reconnect with the next 
            available service and send the message again.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouter.OnOutputChannelResponseMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            It is called when a response message from the service is received.
            The response message must be redirected to the associated client.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouter.OnOutputChannelConnectionClosed(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs)">
            <summary>
            It is called when a connection with the receiver is broken.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpRequestContext.GetRequestMessage">
            <summary>
            Returns the body content of the HTTP request.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpRequestContext.Response(System.Byte[])">
            <summary>
            Responses back to the HTTP client.
            </summary>
            <param name="message">body content.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpRequestContext.ResponseError(System.Int32)">
            <summary>
            Responses back the error.
            </summary>
            <param name="statusCode"></param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.IRpcService`1">
            <summary>
            Service which exposes the interface for Remote Procedure Call (note: it also works with .NET).
            </summary>
            <typeparam name="TServiceInterface">Service interface.</typeparam>
            <remarks>
            RpcService acts as a stub which provides the communication functionality for an instance implementing the given service interface.<br/>
            The provided service type must be an interface fulfilling following criteria:
            <ul>
            <li>Interface is not generic.</li>
            <li>Methods are not overloaded. It means there are no two methods with the same name.</li>
            <li>It can use events.</li>
            </ul>
            
            <example>
            Declaring the service.
            <code>
            public interface IHello
            {
                // Events work too.
                event EventHandler&lt;MyEventArgs&gt; SomethingHappened;
            
                int Sum(int a, int b);
            
                void DoSomething();
            }
            </code>
            </example>
            
            <example>
            The following example shows how to declare interface that can be used for Java/C# communication.
            <code>
            // C# interface
            public interface IMyInterface
            {
               // Event without arguments.
               event EventHandler SomethingHappened;
               
               // Event with arguments.
               event EventHandler&lt;MyEventArgs&gt; SomethingElseHappened;
               
               // Simple method.
               void DoSomething();
               
               // Method with arguments.
               int Calculate(int a, int b);
            }
            </code>
            
            <code>
            // Java equivalent
            // Note: Names of methods and events must be same. So e.g. if the interface is declared in .NET with
            //       then you may need to start method names with Capital.
            public interface IMyInterface
            {
               // Event without arguments.
               Event&lt;EventArgs&gt; SomethingHappened();
               
               // Event with arguments.
               Event&lt;MyArgs&gt; SomethingElseHappened();
               
               // Simple method.
               void DoSomething();
               
               // Method with arguments.
               int Calculate(int a, int b);
            }
            </code>
            </example>
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Rpc.IRpcService`1.ResponseReceiverConnected">
            <summary>
            Event raised when a client connected the service.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Rpc.IRpcService`1.ResponseReceiverDisconnected">
            <summary>
            Event raised when a client got disconnected from the service.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.RsaSerializer">
            <summary>
            Serializer using RSA.
            </summary>
            <remarks>
            The serialization:
            <ol>
            <li>Incoming data is serialized by underlying serializer (e.g. XmlStringSerializer)</li>
            <li>The random key is generated and used with AES algorythm to encrypt the serialized data.</li>
            <li>The random key for AES is encrypted by RSA using the public key.</li>
            <li>The serialized data consits of AES encrypted data and RSA encrypted key for AES.</li>
            </ol>
            The deserialization:
            <ol>
            <li>The receiver decrypts the AES key by RSA using its private key.</li>
            <li>Decrypted key is used to decrypt AES encrypted data.</li>
            <li>Decrypted data is deserialized by underlying serialized (e.g. XmlStringSerializer)</li>
            <li>The deserialization returns deserialized data.</li>
            </ol>
            <br/>
            <example>
            Example shows how to serialize/deserialize data.
            <code>
            // Generate public and private keys.
            RSACryptoServiceProvider aCryptoProvider = new RSACryptoServiceProvider();
            RSAParameters aPublicKey = aCryptoProvider.ExportParameters(false);
            RSAParameters aPrivateKey = aCryptoProvider.ExportParameters(true);
            
            // Create the serializer.
            RsaSerializer aSerializer = new RsaSerializer(aPublicKey, aPrivateKey);
            
            // Serialize data.
            object aSerializedData = aSerializer.Serialize&lt;string&gt;("Hello world.");
            
            
            // Deserialize data.
            string aDeserializedData = aSerializer.Deserialize&lt;string&gt;(aSerializedData);
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RsaSerializer.#ctor(System.Security.Cryptography.RSAParameters,System.Security.Cryptography.RSAParameters)">
            <summary>
            Constructs the RSA serializer with default paraneters.
            </summary>
            <remarks>
            It uses XmlStringSerializer and it will generate
            128 bit key for the AES algorythm.
            </remarks>
            <param name="publicKey">public key used for serialization. If the serializer is used only for deserialization then you can provide
            a dummy key e.g. new RSAParameters().
            </param>
            <param name="privateKey">private key used for deserialization. If the serializer is used only for serialization then you can provide
            a dummy key e.g. new RSAParameters().
            </param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RsaSerializer.#ctor(System.Security.Cryptography.RSAParameters,System.Security.Cryptography.RSAParameters,System.Int32,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the RSA serializer with custom parameters.
            </summary>
            <param name="publicKey">public key used for serialization. If the serializer is used only for deserialization then you can provide
            a dummy key e.g. new RSAParameters().
            </param>
            <param name="privateKey">private key used for deserialization. If the serializer is used only for serialization then you can provide
            a dummy key e.g. new RSAParameters().
            </param>
            <param name="aesBitSize">size of the random key generated for the AES encryption, 128, 256, ...</param>
            <param name="underlyingSerializer">underlying serializer used to serialize/deserialize data e.g. XmlStringSerializer</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RsaSerializer.Serialize``1(``0)">
            <summary>
            Serializes data.
            </summary>
            <typeparam name="_T">data type to be serialized</typeparam>
            <param name="dataToSerialize">data to be serialized</param>
            <returns>serialized data</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.RsaSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data.
            </summary>
            <typeparam name="_T">data type to be deserialized</typeparam>
            <param name="serializedData">serialized data</param>
            <returns>deserialized data type</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer">
            <summary>
            Serializes data to XML using the DataContractSerializer.
            </summary>
            <remarks>
            The serializer is based on DataContractSerializer provided by .Net and it supports
            attributes (DataContract, DataMember, ...) specifying how data is serialized/deserialized.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.#ctor">
            <summary>
            Creates the serializer based on DataContractSerializer with default settings.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.#ctor(System.Func{System.Type,System.Runtime.Serialization.XmlObjectSerializer})">
            <summary>
            Creates the serializer that allows user to specify his own method to instantiate DataContractSerializer
            with desired settings.
            </summary>
            <param name="dataContractFactoryMethod">
            The factory method responsible for creation of DataContractSerializer.
            The factory method is called during the serialization or deserialization.<br/>
            The factory method can be called from more threads at the same time, so be sure, your factory method
            is thread safe.
            </param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the xml string.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>xml string</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data serialized in xml string.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.AesSerializer">
            <summary>
            Serializer using AES (Advanced Encryption Standard).
            </summary>
            <remarks>
            The serializer uses an underlying serializer to serialize and deserialize data.
            Data encoded by the underlying serializer is then encrypted by AES.
            <example>
            Encrypted serialization with <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>
            <code>
            // Create the serializer. The defualt constructor uses XmlStringSerializer.
            AesSerializer aSerializer = new AesSerializer("My password.");
            
            // Create some data to be serialized.
            MyData aData = new MyData();
            ...
            
            // Serialize data with using AES.
            object aSerializedData = aSerializer.Serialize&lt;MyData&gt;(aData);
            </code>
            </example>
            <br/><br/>
            Notice, since AesSerializer serializes into array of bytes, it is not possible to use this serializer
            for the communication between two Silverlight applications. The communication between two silverlight applications
            requires, that data is serialized into the string.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String)">
            <summary>
            Constructs the serializer. It uses <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/> as the underlying serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String,System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
            <param name="salt">additional value used to calculate the key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String,System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Int32)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate the key</param>
            <param name="salt">additional value used to calculate the key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
            <param name="keyBitSize">bit size of the key e.g. 128, 256</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Security.Cryptography.DeriveBytes,System.Int32)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
            <param name="passwordBasedKeyGenerator">generator of key from the password</param>
            <param name="keyBitSize">bit size of the key</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.Byte[],System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="key">key</param>
            <param name="iv">initialization vector</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the object.
            The returned object is type of byte[]. Returned bytes are encrypted.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Encrypted data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.NoDispatching">
            <summary>
            Invokes directly without routing.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.NoDispatching.GetDispatcher">
            <summary>
            Returns dispatcher which invokes directly without routing into a thread.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusServiceEventArgs">
            <summary>
            Event arguments used by the message bus when a service is connected / disconnected.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusServiceEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event arguments.
            </summary>
            <param name="serviceAddress">service id.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusServiceEventArgs.ServiceAddress">
            <summary>
            Returns service id.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory">
            <summary>
            Implents the factory creating broker and broker client.
            </summary>
            <remarks>
            The broker is the component that provides functionality for publish-subscribe scenarios.
            IDuplexBrokerClient provides functionality to send notification messages to the broker
            and also to subscribe for desired messages.
            
            <example>
            The example shows how to create and use the broker communicating via TCP.
            <code>
            // Create Tcp based messaging.
            IMessagingSystemFactory aMessagingFactory = new TcpMessagingSystemFactory();
            
            // Create duplex input channel listening to messages.
            IDuplexInputChannel anInputChannel = aMessagingFactory.CreateDuplexInputChannel("tcp://127.0.0.1:7980/");
            
            // Create the factory for the broker.
            IDuplexBrokerFactory aBrokerFactory = new DuplexBrokerFactory();
            
            // Create the broker.
            IDuplexBroker aBroker = aBrokerFactory.CreateBroker();
            
            // Attach the Tcp duplex input channel to the broker and start listening.
            aBroker.AttachDuplexInputChannel(anInputChannel);
            </code>
            
            <code>
            Subscribing for the notification messages.
            
            // Create Tcp based messaging for the silverlight client.
            IMessagingSystemFactory aTcpMessagingFactory = new TcpMessagingSystemFactory();
            
            // Create duplex output channel to send and receive messages.
            myOutputChannel = aTcpMessagingFactory.CreateDuplexOutputChannel("tcp://127.0.0.1:7980/");
            
            // Create the broker client
            IDuplexBrokerFactory aDuplexBrokerFactory = new DuplexBrokerFactory();
            myBrokerClient = aDuplexBrokerFactory.CreateBrokerClient();
            
            // Handler to process notification messages.
            myBrokerClient.BrokerMessageReceived += NotifyMessageReceived;
            
            // Attach the channel to the broker client to be able to send and receive messages.
            myBrokerClient.AttachDuplexOutputChannel(myOutputChannel);
            
            // Subscribe in broker to receive chat messages.
            myBrokerClient.Subscribe("MyChatMessageType");
            
            
            ...
            
            
            // Send message to the broker. The broker will then forward it to all subscribers.
            XmlStringSerializer anXmlSerializer = new XmlStringSerializer();
            object aSerializedChatMessage = anXmlSerializer.Serialize&lt;ChatMessage&gt;(aChatMessage);
            myBrokerClient.SendMessage("MyChatMessageType", aSerializedChatMessage);
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.#ctor">
            <summary>
            Constructs the broker factory with XmlStringSerializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the broker factory with specified serializer.
            </summary>
            <param name="serializer">serializer used by the broker</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.#ctor(System.Boolean)">
            <summary>
            Constructs the broker factory.
            </summary>
            <remarks>
            It allows to specify if the broker client gets notification from the broker for its own published events.
            E.g. if the broker client is subscribed to the event 'StatusChanged' and if this broker client also publishes the
            event 'StatusChanged' then if the parmater publisherCanBeNotified is false the broker client will not get notification events
            from its own published events.
            </remarks>
            <param name="publisherCanBeNotified">false - broker does not send notifications to the broker client
            which published the event.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.#ctor(System.Boolean,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the broker factory.
            </summary>
            <remarks>
            It allows to specify if the broker client gets notification from the broker for its own published events.
            E.g. if the broker client is subscribed to the event 'StatusChanged' and if this broker client also publishes the
            event 'StatusChanged' then if the parmater publisherCanBeNotified is false the broker client will not get notification events
            from its own published events.
            </remarks>
            <param name="publisherCanBeNotified">false - broker does not send notifications to the broker client
            which published the event.
            </param>
            <param name="serializer">serializer used by the broker</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.CreateBrokerClient">
            <summary>
            Creates the broker client.
            </summary>
            <remarks>
            The broker client is able to send messages to the broker (via attached duplex output channel).
            It also can subscribe for messages to receive notifications from the broker.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.CreateBroker">
            <summary>
            Creates the broker.
            </summary>
            <remarks>
            The broker receives messages and forwards them to subscribers.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient">
            <summary>
            Broker client to publish and subscribe messages in the broker.
            </summary>
            <remarks>
            The broker client allows to publish events via the broker, so that broker will forward them to all subscribers.<br/>
            BrokerClient also allows to subscribe for events of interest.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.SendMessage(System.String,System.Object)">
            <summary>
            Publishes the event via the broker.
            </summary>
            <param name="eventId">identifies the event</param>
            <param name="serializedMessage">
            message content. If the message is not a primitive type or string then the input parameter expects the message is already serialized!
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Subscribe(System.String)">
            <summary>
            Subscribes the client for the event.
            </summary>
            <param name="eventId">type of event that shall be observed</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Subscribe(System.String[])">
            <summary>
            Subscribes the client for list of events.
            </summary>
            <param name="eventIds">list of events that shall be observed</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.SubscribeRegExp(System.String)">
            <summary>
            Subscribes the client for event types matching with the given regular expression.
            </summary>
            <remarks>
            When a published message comes to the broker, the broker will check the event id
            and will forward it to all subscribed clients.<br/>
            The broker will use the given regular expression to recognize whether the client is subscribed
            or not.<br/>
            The .NET based Broker internally uses Regex class to evaluate the regular expression.<br/>
            The Java based Broker internally uses Pattern class to evaluate the regular expression.<br/>
            Regular expressions between .NET and Java does not have to be fully compatible.
            
            <example>
            Few examples for subscribing via regular expression.
            <code>
            // Subscribing for message types starting with the string MyMsg.Speed
            myDuplexBrokerClient.SubscribeRegExp(@"^MyMsg\.Speed);
            
            // Subscribing for message types starting with MyMsg.Speed or App.Utilities
            myDuplexBrokerClient.SubscribeRegExp(@"^MyMsg\.Speed|^App\.Utilities");
            </code>
            </example>
            </remarks>
            <param name="regularExpression">
            Regular expression that will be evaluated by the broker to recognize whether the client is subscribed.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.SubscribeRegExp(System.String[])">
            <summary>
            Subscribes the client for message types matching with the given list of regular expressions.
            </summary>
            <remarks>
            When a published message comes to the broker, the broker will check the message type id
            and will forward it to all subscribed clients.<br/>
            The broker will use the given regular expression to recognize whether the client is subscribed
            or not.<br/>
            The .NET based Broker internally uses Regex class to evaluate the regular expression.<br/>
            The Java based Broker internally uses Pattern class to evaluate the regular expression.<br/>
            Regular expressions between .NET and Java does not have to be fully compatible.
            </remarks>
            <param name="regularExpressions">
            List of regular expressions that will be evaluated by the broker to recognize whether the client is subscribed.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe(System.String)">
            <summary>
            Unsubscribes the client from the specified event.
            </summary>
            <param name="eventId">type of event which shall not be observed anymore</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe(System.String[])">
            <summary>
            Unsubscribes the client from specified events.
            </summary>
            <param name="eventIds">list of events that shall not be observed anymore</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.UnsubscribeRegExp(System.String)">
            <summary>
            Removes the regular expression subscription.
            </summary>
            <remarks>
            When the broker receives this request, it will search if the given regular expression string
            exists for the calling client. If yes, it will be removed.
            </remarks>
            <param name="regularExpression">Regular expression that was previously used for the subscription
            and now shall be removed.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.UnsubscribeRegExp(System.String[])">
            <summary>
            Removes regular expression subscriptions.
            </summary>
            <remarks>
            When the broker receives this request, it will search if the given regular expression strings
            exist for the calling client. If yes, they will be removed.
            </remarks>
            <param name="regularExpressions">Regular expressions that shall be removed from subscriptions.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe">
            <summary>
            Unsubscribes this client from all types of events and regular expressions.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.ConnectionOpened">
            <summary>
            Event raised when the connection with the service was open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.ConnectionClosed">
            <summary>
            Event raised when the connection with the service was closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.BrokerMessageReceived">
            <summary>
            The event is invoked when the observed event is received from the broker.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.NamespaceDoc">
            <summary>
            Communication with a working thread.
            </summary>
            <remarks>
            The messaging system transferring messages to a working thread.
            Received messages are stored in the queue which is then processed by one working thread.
            Therefore the messages are processed synchronously but it does not block receiving. 
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouterFactory">
            <summary>
            Factory creating backup connection router.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouterFactory">
            <summary>
            Declares the factory for creating the backup connection router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.IBackupConnectionRouterFactory.CreateBackupConnectionRouter">
            <summary>
            Creates the backup connection router.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouterFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="outputMessagingFactory">messaging system used to connect services (receivers) via the duplex output channels
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.BackupConnectionRouterFactory.CreateBackupConnectionRouter">
            <summary>
            Creates the backup connection router.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer">
            <summary>
            Serializes data to XML (compatible with Java).
            </summary>
            <remarks>
            This is the default serializer used by the framework. The serializer is compatible
            with XmlStringSerializer from Eneter Messaging Framework for .NET.
            Therefore, you can use it for the communication between Java and .NET applications.
            <b>The serializer does not support generic types on Java and Android platforms!</b>
            <br/>
            The serializer internally uses XmlSerializer provided by .Net.
            <example>
            Serialization and deserialization example.
            <code>
            // Some class to be serialized.
            public class MyClass
            {
                public int Value1 { get; set; }
                public string Value2 { get; set; }
            }
            
            ...
            
            MyClass c = new MyClass;
            c.Value1 = 10;
            c.Value2 = "Hello World.";
            
            ...
            
            // Serialization
            XmlStringSerializer aSerializer = new XmlStringSerializer();
            object aSerializedObject = aSerializer.Serialize&lt;MyClass&gt;(c);
            
            ...
            
            // Deserialization
            XmlStringSerializer aSerializer = new XmlStringSerializer();
            object aDeserializedObject = aSerializer.Deserialize&lt;MyClass&gt;(aSerializedObject);
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.#ctor">
            <summary>
            Creates the serializer based on XmlSerializer with default settings.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.#ctor(System.Func{System.Type,System.Xml.Serialization.XmlSerializer})">
            <summary>
            Creates the serializer that allows user to specify his own method instantiating XmlSerializer
            with desired settings.
            </summary>
            <param name="xmlSerializerFactoryMethod">
            The factory method responsible for creation of XmlSerializer.
            The factory method is called during the serialization or deserialization.<br/>
            The factory method can be called from more threads at the same time, so be sure, your factory method
            is thread safe.
            </param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the xml string.
            </summary>
            <remarks>
            It internally XmlSerializer provided by .Net.
            </remarks>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>xml string</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <remarks>
            It internally XmlSerializer provided by .Net.
            </remarks>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.NamespaceDoc">
            <summary>
            Functionality for routing messages to a different address.
            </summary>
            <remarks>
            Router receives messages and routes them to a different preconfigured address.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer">
            <summary>
            Load balancer.
            </summary>
            <remarks>
            The load balancer maintains a list of receivers processing a certain request.
            When the balancer receives the request, it chooses which receiver shall process it,
            so that all receivers are loaded optimally.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer.AddDuplexOutputChannel(System.String)">
            <summary>
            Adds the request receiver to the load balancer.
            </summary>
            <param name="channelId">channel id (address) of the receiver processing requests.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer.RemoveDuplexOutputChannel(System.String)">
            <summary>
            Removes the request receiver from the load balancer.
            </summary>
            <param name="channelId">channel id (address) of the receiver processing requests.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer.RemoveAllDuplexOutputChannels">
            <summary>
            Removes all request receiers from the load balanacer.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer.ResponseReceiverConnected">
            <summary>
            The event is invoked when the client sending requests was connected to the load balancer.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the client sending requests was disconnected from the load balanacer.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancer.RequestReceiverRemoved">
            <summary>
            The event is invoked when a service receiving requests from the load balancer got disconnected.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancerFactory">
            <summary>
             Creates the load balancer.
            </summary>
            <remarks>
            The load balancer distributes the workload across a farm of receivers that can run on different machines (or threads).
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.ILoadBalancerFactory.CreateLoadBalancer">
            <summary>
            Creates the load balancer.
            </summary>
            <returns>load balancer</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType">
            <summary>
            Indicates the type of the low-level protocol message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType.Unknown">
            <summary>
            Unknown message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType.OpenConnectionRequest">
            <summary>
            Open connection request message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType.CloseConnectionRequest">
            <summary>
            Close connection request message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType.MessageReceived">
            <summary>
            Message or reaponse message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage">
            <summary>
            Represents decoded low-level protocol message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType,System.String,System.Object)">
            <summary>
            Constructs the protocol message from the given parameters.
            </summary>
            <param name="messageType">type of the message</param>
            <param name="responseReceiverId">client id</param>
            <param name="message">message content</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.MessageType">
            <summary>
            Type of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.ResponseReceiverId">
            <summary>
            Client id.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.Message">
            <summary>
            The content of the message or response message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory">
            <summary>
            Combines buffered messaging and the connection monitoring.
            </summary>
            <remarks>
            Monitored messaging constantly monitors the connection. If the monitoring detects the connection is interrupted
            sent messages are stored in the buffer. Then when the connection is recovered the messages stored in the buffer
            are sent.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default settings.
            </summary>
            <remarks>
            The serializer for the 'ping' messages checking the connection is set to <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The maximum offline time is set to 10 seconds.
            The duplex output channel will check the connection with the 'ping' once per second and the response must be received within 2 seconds.
            Otherwise the connection is closed.<br/>
            The duplex input channel expects the 'ping' request at least once per 2 seconds. Otherwise the duplex output
            channel is disconnected.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with the specified parameters.
            </summary>
            <remarks>
            The maximum offline time is set to 10 seconds.
            The duplex output channel will check the connection with the 'ping' once per second and the response must be received within 2 seconds.
            Otherwise the connection is closed.<br/>
            The duplex input channel expects the 'ping' request at least once per 2 seconds. Otherwise the duplex output
            channel is disconnected.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system</param>
            <param name="serializer">serializer used to serialize the 'ping' requests</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Constructs the factory with the specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system</param>
            <param name="serializer">serializer used to serialize the 'ping' requests</param>
            <param name="maxOfflineTime">the maximum time, the messaging can work offline. When the messaging works offline,
            the sent messages are buffered and the connection is being reopened. If the connection is
            not reopen within maxOfflineTime, the connection is closed.
            </param>
            <param name="pingFrequency">how often the connection is checked with the 'ping' requests.</param>
            <param name="pingResponseTimeout">the maximum time, the response for the 'ping' is expected.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            This duplex output channel provides the buffered messaging and the connection monitoring.
            The channel regularly checks if the connection is available. It sends 'ping' requests and expects 'ping' responses
            within the specified time. If the 'ping' response does not come, the buffered messaging layer is notified,
            that the connection was interrupted.
            The buffered messaging then tries to reconnect and stores sent messages to the buffer.
            If the connection is open, the buffered messages are sent.
            If the reconnection was not successful, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/>
            and deletes messages from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>buffered and monitored duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            This duplex output channel provides the buffered messaging and the connection monitoring.
            The channel regularly checks if the connection is available. It sends 'ping' requests and expects 'ping' responses
            within the specified time. If the 'ping' response does not come, the buffered messaging layer is notified,
            that the connection was interrupted.
            The buffered messaging then tries to reconnect and stores sent messages to the buffer.
            If the connection is open, the buffered messages are sent.
            If the reconnection was not successful, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/>
            and deletes messages from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">the unique id of this response receiver</param>
            <returns>buffered and monitored duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending the response messages.
            </summary>
            <remarks>
            This duplex input channel provides the buffered messaging and the connection monitoring.
            The channel regularly checks if the duplex output channel is still connected. It expect, that every connected duplex output channel
            sends regularly 'ping' messages. If the 'ping' message from the duplex output channel is not received within the specified
            time, the duplex output channel is disconnected and the buffered messaging (as the layer above) is notified about the
            disconnection.
            The buffered messaging then puts all sent response messages to the buffer and waits whether the duplex output channel reconnects.
            If the duplex output channel reopens the connection, the buffered response messages are sent.
            If the duplex output channel does not reconnect, the event
            <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected"/> is invoked and rsponse messages are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>buffered and monitored duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.NamespaceDoc">
            <summary>
            Tracing.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Streaming.NamespaceDoc">
            <summary>
            Helper to write and read messages sfrom a stream.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusFactory">
            <summary>
            Implements factory for creating the message bus.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusFactory.#ctor">
            <summary>
            Constructs the factory with default parameters.
            </summary>
            <remarks>
            Default EneterProtocolFormatter is used.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Construct the factory.
            </summary>
            <param name="protocolFormatter">This protocol formatter must be exactly same as is used by both channels that will be attached to the message bus.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusFactory.CreateMessageBus">
            <summary>
            Instantiates the message bus.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory">
            <summary>
            Messaging system delivering messages to the particular working thread.
            </summary>
            <remarks>
            Each input channel is represented by its own working thread removing messages from the queue and processing them
            one by one.
            <br/><br/>
            Different instances of ThreadMessagingSystemFactory are independent and so they
            are different messaging systems. Therefore if you want to send/receive a message with this messaging system
            then output and input channels must be created by the same instance of ThreadMessagingSystemFactory.
            <br/><br/>
            Notice, the messages are always received in one particular working thread, but the notification events e.g. connection opened
            are invoked in a different thread.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.#ctor">
            <summary>
            Constructs thread based messaging factory.
            </summary>
            <remarks>
            Every instance of the synchronous messaging system factory represents one messaging system.
            It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs thread based messaging factory.
            </summary>
            <remarks>
            Every instance of the synchronous messaging system factory represents one messaging system.
            It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </remarks>
            <param name="protocolFormatter">low-level message formatter for the communication between channels.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the working thread.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the working thread.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using the working thread.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">Identifies this duplex input channel.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.InputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex input channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed by one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.DataWrapper">
            <summary>
            Implements the wrapper/unwrapper of data.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DataWrapper.Wrap(System.Object,System.Object,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Adds the data to already serialized data.
            </summary>
            <remarks>
            It creates the <see cref="T:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData"/> from the given data and serializes it with the provided serializer.<br/>
            </remarks>
            <param name="addedData">Added data. It must a basic .Net type. Otherwise the serialization will fail.</param>
            <param name="originalData">Already serialized data - it is type of string or byte[].</param>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DataWrapper.Unwrap(System.Object,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Takes the serialized WrappedData and deserializes it with the given serializer.
            </summary>
            <param name="wrappedData">data serialized by 'Wrap' method</param>
            <param name="serializer">serializer</param>
            <returns>deserialized WrappedData</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.RpcMessage">
            <summary>
            Internal message used for the communication between RpcClient and RpcService.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcMessage.Id">
            <summary>
            Identifies the request on the client side.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcMessage.Flag">
            <summary>
            Identifies the type of the request/response message.
            </summary>
            <remarks>
            e.g. if it is InvokeMethod, MethodResponse, SubscribeEvent, UnsubscribeEvent, RaiseEvent.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcMessage.OperationName">
            <summary>
            The name of the operation that shall be performed.
            </summary>
            <remarks>
            e.g. in case of InvokeMethod it specifies which method shall be invoked.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcMessage.SerializedData">
            <summary>
            Message data.
            </summary>
            <remarks>
            e.g. in case of InvokeMethod it contains input parameters data.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Rpc.RpcMessage.Error">
            <summary>
            If an error occurred in the service.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.SyncDispatching">
            <summary>
            Invokes one by one from from the queue.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.SyncDispatching.#ctor">
            <summary>
            Constructs dispatching where each GetDispatcher() will return new instance of the dispatcher.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.SyncDispatching.#ctor(System.Boolean)">
            <summary>
            Constructor which allows to specify if GetDispatcher() returns always the same dispatcher or GetDispatcher()
            returns always the new instance the dispatcher.
            </summary>
            <param name="isDispatcherShared">
            true - GetDispatcher() will return always the same instance of the dispatcher. It means all dispatchers returned from
            GetDispatcher() will sync incoming methods using the same queue. <br/>
            false - GetDispatcher() will return always the new instance of the dispatcher. It means each dispatcher returned from
            GetDispatcher() will use its own synchronization queue.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.SyncDispatching.GetDispatcher">
            <summary>
            Returns dispatcher that queues callback methods and processes them one by one.
            </summary>
            <remarks>
            If SyncDispatching was created with isDispatcherShared true then it always returns the same instance
            of the thread dispatcher. Otherwise it always creates the new one. 
            </remarks>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory">
            <summary>
            Messaging system delivering messages synchronously (like a synchronous local call).
            </summary>
            <remarks>
            It creates output and input channels using the caller thread to deliver messages.
            <br/><br/>
            Different instances of SynchronousMessagingSystemFactory are independent and so they
            are different messaging systems. Therefore if you want to send/receive a message through this messaging system
            then output and input channels must be created with the same instance of SynchronousMessagingSystemFactory.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory representing the messaging system.
            </summary>
            <remarks>
            Note: Every instance of the synchronous messaging system factory represents one messaging system.
                  It means that two instances of this factory class creates channels for two independent messaging system.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the factory representing the messaging system.
            </summary>
            <param name="protocolFormatter">formatter used to encode low-level messages between channels</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel communicating with the specified duplex input channel using synchronous local call.
            </summary>
            <remarks>
            The duplex output channel can send messages and receive response messages.
            </remarks>
            <param name="channelId">identifies the receiving duplex input channel</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel communicating with the specified duplex input channel using synchronous local call.
            </summary>
            <remarks>
            The duplex output channel can send messages and receive response messages.
            </remarks>
            <param name="channelId">identifies the receiving duplex input channel</param>
            <param name="responseReceiverId">identifies the response receiver of this duplex output channel</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel listening to messages on the specified channel id.
            </summary>
            <remarks>
            The duplex input channel can send response messages back to the duplex output channel.
            </remarks>
            <param name="channelId">identifies this duplex input channel</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.InputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex input channel according to
            desired threading strategy.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.NamespaceDoc">
            <summary>
            Helper functionality to create and attach channels to components.
            </summary>
            <remarks>
            This connecting functionality helps to reduce the amount of coding. It connects communicating components with channels.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory">
            <summary>
            Factory to create reliable typed message senders and receivers.
            </summary>
            <remarks>
            The reliable messaging means that the sender is notified whether the message was delivered or not.
            <example>
            Example of a simple service using the reliable messaging for the communication.
            (The service calculates two numbers and sends back responses.)
            <code>
            using System;
            using Eneter.Messaging.EndPoints.TypedMessages;
            using Eneter.Messaging.MessagingSystems.MessagingSystemBase;
            using Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem;
            
            namespace CalculatorService
            {
                // Request message.
                public class RequestMessage
                {
                    public int Number1 { get; set; }
                    public int Number2 { get; set; }
                }
            
                // Response message.
                public class ResponseMessage
                {
                    public int Result { get; set; }
                }
            
                class Program
                {
                    static void Main(string[] args)
                    {
                        // Create reliable message receiver.
                        IReliableTypedMessagesFactory aReceiverFactory = new ReliableTypedMessagesFactory();
                        IReliableTypedMessageReceiver&lt;ResponseMessage, RequestMessage&gt; aReceiver =
                            aReceiverFactory.CreateReliableDuplexTypedMessageReceiver&lt;ResponseMessage, RequestMessage&gt;();
            
                        // Subscribe to be notified whether sent response messages
                        // were received.
                        aReceiver.ResponseMessageDelivered += OnResponseMessageDelivered;
                        aReceiver.ResponseMessageNotDelivered += OnResponseMessageNotDelivered;
            
                        // Subscribe to process request messages.
                        aReceiver.MessageReceived += OnMessageReceived;
            
                        // Use WebSocket for the communication.
                        // Note: You can also other messagings. E.g. TcpMessagingSystemFactory
                        IMessagingSystemFactory aMessaging = new WebSocketMessagingSystemFactory();
                        IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("ws://192.168.1.102:8099/aaa/");
            
                        // Attach the input channel to the receiver and start listening.
                        aReceiver.AttachDuplexInputChannel(anInputChannel);
            
                        Console.WriteLine("The calculator service is running. Press ENTER to stop.");
                        Console.ReadLine();
            
                        // Detach the input channel to stop listening.
                        aReceiver.DetachDuplexInputChannel();
                    }
            
                    private static void OnMessageReceived(object sender, TypedRequestReceivedEventArgs&lt;RequestMessage&gt; e)
                    {
                        // Calculate numbers.
                        ResponseMessage aResponseMessage = new ResponseMessage();
                        aResponseMessage.Result = e.RequestMessage.Number1 + e.RequestMessage.Number2;
            
                        Console.WriteLine("{0} + {1} = {2}", e.RequestMessage.Number1, e.RequestMessage.Number2, aResponseMessage.Result);
            
                        // Send back the response message.
                        var aReceiver = (IReliableTypedMessageReceiver&lt;ResponseMessage, RequestMessage&gt;)sender;
                        string aResponseId = aReceiver.SendResponseMessage(e.ResponseReceiverId, aResponseMessage);
            
                        Console.WriteLine("Sent response has Id: {0}", aResponseId);
                    }
            
                    private static void OnResponseMessageDelivered(object sender, ReliableMessageIdEventArgs e)
                    {
                        Console.WriteLine("Response Id: {0} was delivered.", e.MessageId);
                    }
            
                    private static void OnResponseMessageNotDelivered(object sender, ReliableMessageIdEventArgs e)
                    {
                        Console.WriteLine("Response Id: {0} was NOT delivered.", e.MessageId);
                    }
                }
            }
            </code>
            </example>
            
            <example>
            Example showing a simple client using reliable messaging for the communication.
            (The client sends a request to calculate two numbers.)
            <code>
            using System;
            using System.Windows.Forms;
            using Eneter.Messaging.EndPoints.TypedMessages;
            using Eneter.Messaging.MessagingSystems.MessagingSystemBase;
            using Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem;
            
            namespace CalculatorClientSync
            {
                public partial class Form1 : Form
                {
                    // Request message.
                    public class RequestMessage
                    {
                        public int Number1 { get; set; }
                        public int Number2 { get; set; }
                    }
            
                    // Response message.
                    public class ResponseMessage
                    {
                        public int Result { get; set; }
                    }
            
                    private IReliableTypedMessageSender&lt;ResponseMessage, RequestMessage&gt; mySender;
            
                    public Form1()
                    {
                        InitializeComponent();
            
                        OpenConnection();
                    }
            
                    private void Form1_FormClosed(object sender, FormClosedEventArgs e)
                    {
                        CloseConnection();
                    }
            
            
                    private void OpenConnection()
                    {
                        // Create the message sender.
                        IReliableTypedMessagesFactory aSenderFactory = new ReliableTypedMessagesFactory();
                        mySender = aSenderFactory.CreateReliableDuplexTypedMessageSender&lt;ResponseMessage, RequestMessage&gt;();
            
                        // Subscribe to be notified whether the request message was delivered or not.
                        mySender.MessageDelivered += OnMessageDelivered;
                        mySender.MessageNotDelivered += OnMessageNotDelivered;
            
                        // Subscribe to receive response messages.
                        mySender.ResponseReceived += OnResponseReceived;
            
                        // Use Websocket for the communication.
                        // If you want to use TCP then use TcpMessagingSystemFactory().
                        IMessagingSystemFactory aMessaging = new WebSocketMessagingSystemFactory();
                        IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("ws://192.168.1.102:8099/aaa/");
            
                        // Attach the output channel and be able to send messages
                        // and receive response messages.
                        mySender.AttachDuplexOutputChannel(anOutputChannel);
                    }
            
                    private void CloseConnection()
                    {
                        // Detach input channel and stop listening to response messages.
                        mySender.DetachDuplexOutputChannel();
                    }
            
                    private void CalculateBtn_Click(object sender, EventArgs e)
                    {
                        // Create the request message.
                        RequestMessage aRequest = new RequestMessage();
                        aRequest.Number1 = int.Parse(Number1TextBox.Text);
                        aRequest.Number2 = int.Parse(Number2TextBox.Text);
            
                        // Send request to the service to calculate 2 numbers.
                        string aRequestId = mySender.SendRequestMessage(aRequest);
            
                        SentMessageIdlabel.Text = "Request Id: " + aRequestId;
                    }
            
                    private void OnResponseReceived(object sender, TypedResponseReceivedEventArgs&lt;ResponseMessage&gt; e)
                    {
                        // Display the result using the UI thread.
                        UI(() =&gt; ResultTextBox.Text = e.ResponseMessage.Result.ToString());
                    }
            
                    private void OnMessageDelivered(object sender, ReliableMessageIdEventArgs e)
                    {
                        // Display the message was delivered.
                        UI(() =&gt; DeliveryResultLabel.Text = "Delivered: " + e.MessageId);
                    }
            
                    private void OnMessageNotDelivered(object sender, ReliableMessageIdEventArgs e)
                    {
                        // Display the message was NOT delivered.
                        UI(() =&gt; DeliveryResultLabel.Text = "NOT delivered: " + e.MessageId);
                    }
            
                    // Helper method to invoke a delegate in the UI thread.
                    // Note: You can manipulate UI controls only from the UI tread.
                    private void UI(Action action)
                    {
                        if (InvokeRequired)
                        {
                            Invoke(action);
                        }
                        else
                        {
                            action();
                        }
                    }
                }
            }
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.#ctor">
            <summary>
            Constructs the factory with default settings.
            </summary>
            <remarks>
            For the serialization of reliable messages is used <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The maximum time, the acknowledge message must be received is set to 12 seconds.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.#ctor(System.TimeSpan)">
            <summary>
            Constructs the factory.
            </summary>
            <remarks>
            For the serialization of reliable messages is used <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            </remarks>
            <param name="acknowledgeTimeout">The maximum time until the delivery of the message must be acknowledged.</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.#ctor(System.TimeSpan,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="acknowledgeTimeout">The maximum time until the delivery of the message must be acknowledged.</param>
            <param name="serializer">Serializer used to serialize messages.</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.CreateReliableDuplexTypedMessageSender``2">
            <summary>
            Creates the reliable message sender.
            </summary>
            <typeparam name="_ResponseType">type of response message</typeparam>
            <typeparam name="_RequestType">type of request message</typeparam>
            <returns>reliable typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.CreateReliableDuplexTypedMessageReceiver``2">
            <summary>
            Creates the reliable message receiver.
            </summary>
            <typeparam name="_ResponseType">type of response message</typeparam>
            <typeparam name="_RequestType">type of request message</typeparam>
            <returns>reliable typed message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.BackupRouter.RedirectEventArgs">
            <summary>
            The event data available when the original connection is replaced with new connection.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.BackupRouter.RedirectEventArgs.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructs the event.
            </summary>
            <param name="forResponseReceiverId">Client connected to the backup router for which the connection was redirected.</param>
            <param name="fromAddress">Original service address.</param>
            <param name="toAddress">New service address.</param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.BackupRouter.RedirectEventArgs.ForResponseReceiverId">
            <summary>
            Gets client connected to the backup router for which the connection was redirected.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.BackupRouter.RedirectEventArgs.FromAddress">
            <summary>
            Gets original service address.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.BackupRouter.RedirectEventArgs.ToAddress">
            <summary>
            Gets new service address.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType">
            <summary>
            Defines data frames as specified by the websocket protocol.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Continuation">
            <summary>
            Frame contains message data that was not sent in one 'Text' or 'Binary'.
            Message that is split into multiple frames.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Text">
            <summary>
            Frame contains UTF8 text message data.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Binary">
            <summary>
            Frame contains binary data.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Close">
            <summary>
            Control frame indicating the connection goes down.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Ping">
            <summary>
            Control frame pinging the end-point (client or server). The pong response is expected.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.EFrameType.Pong">
            <summary>
            Control frame as a response for the ping.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.PathListenerProviderBase`1">
            <summary>
            Base class representing listeners listening on IP address, port and path.
            E.g. websockets and http
            </summary>
            <typeparam name="_TClientContext"></typeparam>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.NamespaceDoc">
            <summary>
            Message serializers.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.IDuplexRouter">
            <summary>
            Declares the duplex router.
            </summary>
            <remarks>
            The duplex router has attached more duplex input channels and uses more duplex output channels.<br/>
            When it receives some message via the duplex input channel, it forwards the message to all configured duplex output channels.<br/>
            This router is bidirectional. Therefore, it can forward messages and also route back response messages from receivers.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.AddConnection(System.String,System.String)">
            <summary>
            Adds the connection configuration to the router. It means when the duplex input channel receives a
            message then the message will be forwarded to the specified duplex output channel too.
            </summary>
            <param name="duplexInputChannelId"></param>
            <param name="duplexOutputChannelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.RemoveConnection(System.String,System.String)">
            <summary>
            Removes the connection configuration from the router.
            </summary>
            <param name="duplexInputChannelId"></param>
            <param name="duplexOutputChannelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.RemoveAllConnections">
            <summary>
            Removes all configurations from the router.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter">
            <summary>
            Implements the protocol formatter encoding the low-level messages into the string.
            </summary>
            <remarks>
            Encoding to the string can be used if the messaging system does not allow tu use byte[].
            E.g. the messaging between Silverlight applications sends only string messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter.EncodeOpenConnectionMessage(System.String)">
            <summary>
            Encodes open connection request.
            </summary>
            <param name="responseReceiverId">client id</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter.EncodeCloseConnectionMessage(System.String)">
            <summary>
            Encodes close connection request.
            </summary>
            <param name="responseReceiverId">client id</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter.EncodeMessage(System.String,System.Object)">
            <summary>
            Encodes a message or a response message.
            </summary>
            <param name="responseReceiverId">client id</param>
            <param name="message">the serialized content of the message</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter.DecodeMessage(System.IO.Stream)">
            <summary>
            Decodes a message or a response message from the stream.
            </summary>
            <param name="readStream">stream containing the low-level message</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter.DecodeMessage(System.String)">
            <summary>
            Decodes a message or a response message from the byte[].
            </summary>
            <param name="encodedMessage">source of the low-level message</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.NamespaceDoc">
            <summary>
            Extension providing monitoring the connection.
            </summary>
            <remarks>
            The monitoring is realized by sending 'ping' messages and receiving 'ping' responses.
            If the sending of the 'ping' fails or the 'ping' response is not received within the specified
            time, the connection is considered broken.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory">
            <summary>
            Extension allowing to work offline until the connection is available.
            </summary>
            <remarks>
            The buffered messaging is intended to overcome relatively short time intervals when the connection is not available.
            It means, the buffered messaging is able to hide the connection is not available and work offline while
            trying to reconnect.<br/>
            If the connection is not available, the buffered messaging stores sent messages (and sent response messages)
            in the buffer and sends them when the connection is established.<br/>
            Buffered messaging also checks if the between duplex output channel and duplex input channel is active.
            If the connection is not used (messages do not flow) the buffered messaging
            waits the specified maxOfflineTime and then disconnects the client.
            <br/>
            <b>Note:</b><br/>
            The buffered messaging does not require that both communicating parts create channels with buffered messaging factory.
            It means, e.g. the duplex output channel created with buffered messaging with underlying TCP, can send messages
            directly to the duplex input channel created with just TCP messaging factory.
            
            <example>
            Simple client buffering messages in case of a disconnection.
            <code>
            // Create TCP messaging.
            IMessagingSystemFactory anUnderlyingMessaging = new TcpMessagingSystemFactory();
            
            // Create buffered messaging that internally uses TCP.
            IMessagingSystemFactory aMessaging = new BufferedMessagingSystemFactory(anUnderlyingMessaging);
            
            // Create the duplex output channel.
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:8045/");
            
            // Create message sender to send simple string messages.
            IDuplexStringMessagesFactory aSenderFactory = new DuplexStringMessagesFactory();
            IDuplexStringMessageSender aSender = aSenderFactory.CreateDuplexStringMessageSender();
            
            // Subscribe to receive responses.
            aSender.ResponseReceived += OnResponseReceived;
            
            // Attach output channel an be able to send messages and receive responses.
            aSender.AttachDuplexOutputChannel(anOutputChannel);
            
            ...
            
            // Send a message. If the connection was broken the message will be stored in the buffer.
            // Note: The buffered messaging will try to reconnect automatically.
            aSender.SendMessage("Hello.");
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default parameters.
            </summary>
            <remarks>
            The maximum offline time will be set to 10 seconds.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. Websocket, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,System.TimeSpan)">
            <summary>
            Constructs the factory from the specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. Websocket, TCP, ...</param>
            <param name="maxOfflineTime">the max time, the communicating applications can be disconnected</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            If the connection is not established, it puts sent messages to the buffer while trying to reconnect.
            Then when the connection is established, the messages are sent from the buffer.
            If the reconnect is not successful within the maximum offline time, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> and messages
            are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>buffered duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            If the connection is not established, it puts sent messages to the buffer while trying to reconnect.
            Then when the connection is established, the message are sent from the buffer.
            If the reconnect is not successful within the maximum offline time, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> and messages
            are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">response receiver id of this duplex output channel</param>
            <returns>buffered duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending the response messages.
            </summary>
            <remarks>
            If the connection with the duplex output channel is not established, it puts sent response messages to the buffer.
            Then, when the duplex input channel is connected, the response messages are sent.
            If the duplex output channel does not connect within the specified maximum offline time, the event
            <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected"/> is invoked and response messages are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>buffered duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs">
            <summary>
            Event type for text response message is received.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseMessage">message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs.ResponseMessage">
            <summary>
            Returns the response message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.NamespaceDoc">
            <summary>
            Communication via UDP.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory">
            <summary>
            Messaging system delivering messages via UDP.
            </summary>
            <remarks>
            It creates the communication channels using UDP for sending and receiving messages.
            The channel id must be a valid UDP URI address. E.g.: udp://127.0.0.1:6080/. <br/>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.#ctor">
            <summary>
            Constructs the UDP messaging factory.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the UDP messaging factory.
            </summary>
            <param name="protocolFromatter">formatter used for low-level messaging between output and input channels.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using UDP.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            <example>
            Creating the duplex output channel.
            <code>
            IMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory();
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("udp://127.0.0.1:8765/");
            </code>
            </example>
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid URI address e.g. udp://127.0.0.1:8090/ </param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using UDP.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            <example>
            Creating the duplex output channel with specified client id.
            <code>
            IMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory();
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("udp://127.0.0.1:8765/", "MyUniqueClientId_1");
            </code>
            </example>
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid URI address e.g. udp://127.0.0.1:8090/ </param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using UDP.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            <example>
            Creating duplex input channel.
            <code>
            IMessagingSystemFactory aMessaging = new UdpMessagingSystemFactory();
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("udp://127.0.0.1:9876/");
            </code>
            </example>
            </remarks>
            <param name="channelId">Identifies this duplex input channel. The channel id must be a valid URI address (e.g. udp://127.0.0.1:8090/) the input channel will listen to.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.InputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex input channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed by one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.UdpMessagingSystem.UdpMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory">
            <summary>
            The factory class creating the security stream allowing authentication as server and encrypted communication
            based on SSL protocol.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="certificate">Server certificate.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="certificate">Server certificate.</param>
            <param name="isClientCertificateRequired">true - if the client identity is verified too.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="certificate">Server certificate.</param>
            <param name="isClientCertificateRequired">true - if the client identity is verified too.</param>
            <param name="userCertificateValidationCallback">User provided delegate for validating the certificate supplied by the remote party.</param>
            <param name="userCertificateSelectionCallback">User provided delegate for selecting the certificate used for authentication.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory.CreateSecurityStreamAndAuthenticate(System.IO.Stream)">
            <summary>
            Creates the security stream and performs the authentication as client.
            </summary>
            <param name="source">The stream wrapped by the security stream.</param>
            <returns>Security stream of type SslStream.</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.HostListenerController">
            <summary>
            Single static class ensuring it is possible to register more listeners using same IP address and port
            but different paths.
            </summary>
            <remarks>
            E.g.: The user code wants to listen to these 3 addresses:
            http://127.0.0.1:9055/aaa/bbb/
            http://127.0.0.1:9055/aaa/ccc/
            http://127.0.0.1:9055/aaa/ddd/
            
            All addresses share the same IP address and port. They are different only in paths.
            This class is responsible for maintaining listeners to IP address and port.
            So that if the user code wants to register next listener it checks if there is a listener to IP address and port.
            If yes, then it registers just the new path.
            If not, then it creates the listener to the IP address and port and register there the path.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.HostListenerController.StartListening(System.Uri,Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.IHostListenerFactory,System.Object,Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ISecurityFactory)">
            <summary>
            Starts listening for the given URI path.
            </summary>
            <remarks>
            The listening consists of two parts:
            => Host listener - TCP listening on an address and port.
            => Path listener - based on the above protocol (HTTP or WebSocket) listening to the path.
            
            If the URI contains hostname instead of the IP address then it resolves the host name.
            But the result can be multiple addresses. E.g. for localhost it can return IPV4: 127.0.0.1 and IPV6: [::1].
            In sach case it will try to start listening to all addresses associated with the host name.
            If start listening fails for one of those addresses then StartListening throws exception.
            
            </remarks>
            <param name="address"></param>
            <param name="hostListenerFactory"></param>
            <param name="connectionHandler"></param>
            <param name="serverSecurityFactory"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.PathListeningBase.HostListenerController.IsListening(System.Uri)">
            <summary>
            Returns true if somebody is listening to the given uri.
            </summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory">
            <summary>
            Implements the messaging system delivering messages via the shared memory.
            </summary>
            <remarks>
            It creates communication channels for sending and receiving messages via shared memory.<br/>
            Communication via the shared memory can transfer messages between applications running on the same machine
            and is significantly faster than using named pipes.<br/>
            Messaging via the shared memeory is supported only in .Net 4.0 or higher.
            <example>
            General using of shared memory.
            <code>
            IMessagingSystemFactory aMessaging = new SharedMemoryMessagingSystemFactory();
            
            // Duplex output channel that can be attached to message senders.
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("MyChannelName");
            
            // Duplex input channel that can be attached to a mesage receiver.
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("MyChannelName");
            </code>
            </example>
            
            <example>
            Windows service listening to messages via shared memory.
            <code>
            public partial class Service1 : ServiceBase
            {
               // Request message coming from the cient.
               public class RequestMessage
               {
                  public int Number1;
                  public int Number2;
               }
               
               // Response message.
               public class ResponseMessage
               {
                  public int Result;
               }
               
               private IDuplexTypedMessageReceiver&lt;ResponseMessage, RequestMessage&gt; myReceiver;
               
               public Service1()
               {
                  InitializeComponent();
               }
               
               protected override void OnStart(string[] args)
               {
                  //EneterTrace.DetailLevel = EneterTrace.EDetailLevel.Debug;
                  //EneterTrace.TraceLog = new StreamWriter("d:/tracefile.txt");
               
                  // Create message receiver.
                  // It receives 'RequestMessage' and responses result in 'int'.
                  IDuplexTypedMessagesFactory aReceiverFactory = new DuplexTypedMessagesFactory();
                  myReceiver = aReceiverFactory.CreateDuplexTypedMessageReceiver&lt;ResponseMessage, RequestMessage&gt;();
               
                  // Subscribe to receive response messages.
                  myReceiver.MessageReceived += OnMessageReceived;
               
                  // Set the security for the shared memory allowing the communication
                  // with desktop applications.
                  MemoryMappedFileSecurity aSharedMemmorySecurity = new MemoryMappedFileSecurity();
                  aSharedMemmorySecurity.SetSecurityDescriptorSddlForm("S:(ML;;NW;;;LW)");
                  SecurityIdentifier aSid = new SecurityIdentifier(WellKnownSidType.WorldSid, null);
                  AccessRule&lt;MemoryMappedFileRights&gt; aRules = new AccessRule&lt;MemoryMappedFileRights&gt;(aSid, MemoryMappedFileRights.ReadWrite, AccessControlType.Allow);
                  aSharedMemmorySecurity.SetAccessRule(aRules);
               
                  // Use Shared messaging for the communication.
                  IMessagingSystemFactory aMessaging = new SharedMemoryMessagingSystemFactory(10485760,
                      new EneterProtocolFormatter(), aSharedMemmorySecurity);
                  IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("MyAddress");
               
                  // Attach the input channel to the message receiver and start listening.
                  myReceiver.AttachDuplexInputChannel(anInputChannel);
               }
               
               protected override void OnStop()
               {
                  if (myReceiver != null)
                  {
                      // Stop listening.
                      // Note: it releases the listening thread.
                      myReceiver.DetachDuplexInputChannel();
                  }
               }
               
               private void OnMessageReceived(object eventSender, TypedRequestReceivedEventArgs&lt;RequestMessage&gt; e)
               {
                  // Calculate received numbers and sends back the response.
                  int aResult = e.RequestMessage.Number1 + e.RequestMessage.Number2;
               
                  string s = string.Format("{0} + {1} = {2}", e.RequestMessage.Number1, e.RequestMessage.Number2, aResult);
                  EneterTrace.Info(s);
               
                  // Send back the response message.
                  ResponseMessage aResponseMessage = new ResponseMessage();
                  aResponseMessage.Result = aResult;
               
                  myReceiver.SendResponseMessage(e.ResponseReceiverId, aResponseMessage);
               }
            }
            </code>
            </example>
            
            <example>
            Desktop client application using shared memory to communicate with Windows service.
            It must use Global prefix in channel name.
            <code>
            public partial class Form1 : Form
            {
                // Request message coming from the cient.
                public class RequestMessage
                {
                    public int Number1;
                    public int Number2;
                }
            
                // Response message.
                public class ResponseMessage
                {
                    public int Result;
                }
            
                private IDuplexTypedMessageSender&lt;ResponseMessage, RequestMessage&gt; mySender;
            
                public Form1()
                {
                    InitializeComponent();
            
                    // Create message sender.
                    // It sends 'RequestMessage' and  receives 'int'.
                    IDuplexTypedMessagesFactory aSenderFactory = new DuplexTypedMessagesFactory();
                    mySender = aSenderFactory.CreateDuplexTypedMessageSender&lt;ResponseMessage, RequestMessage&gt;();
            
                    // Subscribe to receive responses.
                    mySender.ResponseReceived += OnResponseReceived;
            
                    // Use shared messaging for the communication.
                    // Note: Client must use Global if the sevice is Windows Service.
                    IMessagingSystemFactory aMessaging = new SharedMemoryMessagingSystemFactory();
                    IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("Global\\MyAddress");
            
                    // Attach the output channel and be able to send messages
                    // and receive response messages.
                    mySender.AttachDuplexOutputChannel(anOutputChannel);
                }
            
                private void Form1_FormClosed(object sender, FormClosedEventArgs e)
                {
                    // Detach the output channel to stop the listening thread.
                    mySender.DetachDuplexOutputChannel();
                }
            
                private void SendBtn_Click(object sender, EventArgs e)
                {
                    // Create the request message.
                    RequestMessage aRequestMessage = new RequestMessage();
                    aRequestMessage.Number1 = int.Parse(Number1TextBox.Text);
                    aRequestMessage.Number2 = int.Parse(Number2TextBox.Text);
            
                    // Send the request message to the service
                    // to calculate numbers.
                    mySender.SendRequestMessage(aRequestMessage);
                }
            
            
                private void OnResponseReceived(object sender, TypedResponseReceivedEventArgs&lt;ResponseMessage&gt; e)
                {
                    // Display the received result.
                    // But invoke the displaying in the UI thread.
                    UI(() =&gt; ResultTextBox.Text = e.ResponseMessage.Result.ToString());
                }
            
            
                // Helper method to invoke some functionality in UI thread.
                private void UI(Action uiMethod)
                {
                    // If we are not in the UI thread then we must synchronize via the invoke mechanism.
                    if (InvokeRequired)
                    {
                        Invoke(uiMethod);
                    }
                    else
                    {
                        uiMethod();
                    }
                }
            }
            </code>
            </example>
            
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory.#ctor">
            <summary>
            Constructs the messaging factory with the default settings.
            </summary>
            <remarks>
            The default constructor creates the factory that will create input and output channels
            using the shared memory. <br/>
            The maximum message size will be 10Mb.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory.#ctor(System.Int32)">
            <summary>
            Constructs the messaging system with possibility to specify the maximum message size.
            </summary>
            <param name="maxMessageSize">maximum message size in bytes</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory.#ctor(System.Int32,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter{System.Byte[]},System.IO.MemoryMappedFiles.MemoryMappedFileSecurity)">
            <summary>
            Constructs the messaging system.
            </summary>
            <param name="maxMessageSize">maximum message size in bytes</param>
            <param name="protocolFormatter">formats low-level communication between channels.
            The default formatter is EneterProtocolFormatter.
            </param>
            <param name="sharedMemorySecurity">specifies the security that shall be applied for
            the communication via shared memory. Can be null if no security shall be applied.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages
            via shared memory.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.
            The id is the name of the memory-mapped file that
            is used to send and receive messages.
            </param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages
            via shared memory.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.
            The id is the name of the memory-mapped file that
            is used to send and receive messages.
            </param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages
            via the shared memory.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">Identifier of the listening input channel. The id is the name of the memory-mapped file that
            will be used to send and receive messages.
            </param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory.InputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex input channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed by one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SharedMemoryMessagingSystem.SharedMemoryMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory">
            <summary>
            Implementats the messaging system delivering messages via named pipes.
            </summary>
            <remarks>
            It creates the communication channels for sending and receiving messages with using Named Pipes.
            The channel id must be a valid URI address. E.g.: net.pipe//127.0.0.1/SomeName/ . <br/>
            Notice, Silverlight and Windows Phone 7 do not support Named Pipes.
            Therefore, this functionality is not available for these platforms.
            <br/><br/>
            The input channel creates the pipe for the reading and waits for connections. To handle more connections
            in parallel there are more threads serving them (by default 10 threads). Every such thread waits
            for messages and puts them to the message queue. The message queue is connected to one working thread
            that removes messages one by one and notifies subscribers of the input channel.
            Therefore the subscribers are notified always from the same working thread.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory with default parameters.
            </summary>
            <remarks>
            The default parameters are: 10 serving threads, 10 seconds timeout for the disconnection.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs the factory specifying the number of processing threads in the input channel and the timeout
            for the output channel.
            </summary>
            <param name="numberOfInputchannelListeningThreads">
            Number of threads that will listen in parallel in input channels created by the factory.
            The maximum number is 254. Many threads can increase the number of processing connections at the same time
            but it consumes a lot of resources.
            </param>
            <param name="pipeConnectionTimeout">
            The maximum time in miliseconds, the output channel waits to connect the pipe and sends the message.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.#ctor(System.Int32,System.Int32,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter{System.Byte[]})">
            <summary>
            Constructs the factory specifying the number of processing threads in the input channel and the timeout
            for the output channel. It also allows to specify the security settings for the pipe.
            </summary>
            <remarks>
            Security settings can be needed, if communicating processes run under different integrity levels.
            E.g. If the service runs under administrator account and the client under some user account,
            then the communication will not work until the pipe security is not set.
            (Client will get access denied exception.)
            <example>
            The following example shows how to set the pipe security on the service running under administrator
            account to be accessible from client processes.
            <code>
            PipeSecurity aPipeSecurity = new PipeSecurity();
            
            // Set to low integrity level.
            aPipeSecurity.SetSecurityDescriptorSddlForm("S:(ML;;NW;;;LW)");
            
            SecurityIdentifier aSid = new SecurityIdentifier(WellKnownSidType.WorldSid, null);
            ipeAccessRule aPipeAccessRule = new PipeAccessRule(aSid, PipeAccessRights.ReadWrite, AccessControlType.Allow);
            aPipeSecurity.AddAccessRule(aPipeAccessRule);
            
            // Create the messaging communicating via Named Pipes.
            IMessagingSystemFactory aMessagingSystem = new NamedPipeMessagingSystemFactory(10, 10000, aPipeSecurity);
            </code>
            </example>
            </remarks>
            <param name="numberOfInputchannelListeningThreads">
            Number of threads that will listen in parallel in input channels created by the factory.
            The maximum number is 254. Many threads can increase the number of processing connections at the same time
            but it consumes a lot of resources.
            </param>
            <param name="pipeConnectionTimeout">
            The maximum time in miliseconds, the output channel waits to connect the pipe and sends the message.</param>
            <param name="protocolFormatter">formatter of low-level messages between channels</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.#ctor(System.Int32,System.Int32,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter{System.Byte[]},System.IO.Pipes.PipeSecurity)">
            <summary>
            Constructs the factory specifying the number of processing threads in the input channel and the timeout
            for the output channel. It also allows to specify the security settings for the pipe.
            </summary>
            <remarks>
            Security settings can be needed, if communicating processes run under different integrity levels.
            E.g. If the service runs under administrator account and the client under some user account,
            then the communication will not work until the pipe security is not set.
            (Client will get access denied exception.)
            <example>
            The following example shows how to set the pipe security on the service running under administrator
            account to be accessible from client processes.
            <code>
            PipeSecurity aPipeSecurity = new PipeSecurity();
            
            // Set to low integrity level.
            aPipeSecurity.SetSecurityDescriptorSddlForm("S:(ML;;NW;;;LW)");
            
            SecurityIdentifier aSid = new SecurityIdentifier(WellKnownSidType.WorldSid, null);
            ipeAccessRule aPipeAccessRule = new PipeAccessRule(aSid, PipeAccessRights.ReadWrite, AccessControlType.Allow);
            aPipeSecurity.AddAccessRule(aPipeAccessRule);
            
            // Create the messaging communicating via Named Pipes.
            IMessagingSystemFactory aMessagingSystem = new NamedPipeMessagingSystemFactory(10, 10000, aPipeSecurity);
            </code>
            </example>
            </remarks>
            <param name="numberOfPipeInstances">
            Number of clients that can be connected at the same time.
            The maximum number is 254. Many threads can increase the number of processing connections at the same time
            but it consumes a lot of resources.
            </param>
            <param name="pipeConnectionTimeout">
            The maximum time in miliseconds, the output channel waits to connect the pipe and sends the message.</param>
            <param name="protocolFormatter">formatter of low-level messages between channels</param>
            <param name="pipeSecurity">
            Pipe security.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using Named Pipe.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id represents the name of the pipe and must be a valid Uri address e.g. net.pipe//127.0.0.1/SomeName/ </param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using Named Pipe.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id represents the name of the pipe and must be a valid Uri address e.g. net.pipe//127.0.0.1/SomeName/ </param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel. The id cannot be an Uri address. It must be a plain srting.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using Named Pipe.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">Identifies this duplex input channel. The channel id represents the name of the pipe and must be a valid Uri address e.g. net.pipe//127.0.0.1/SomeName/ </param>
            <returns></returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.InputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex input channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed by one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.NamedPipeMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.NamespaceDoc">
            <summary>
            Communication via HTTP.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpRequestInvoker">
            <summary>
            Invokes the HTTP request.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1">
            <summary>
            Thread with the message queue.
            </summary>
            <remarks>
            If a message is put to the queue, the thread removes it from the queue and calls a call-back
            method to process it.
            </remarks>
            <typeparam name="TMessage">type of the message processed by the thread</typeparam>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.RegisterMessageHandler(System.Action{`0})">
            <summary>
            Registers the handler processing messages.
            </summary>
            <param name="messageHandler"></param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.UnregisterMessageHandler">
            <summary>
            Unregisters the handler processing messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.EnqueueMessage(`0)">
            <summary>
            Enqueues the message to the queue.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1">
            <summary>
            Memory message queue.
            </summary>
            <remarks>
            One or more threads can put messages into the queue and other threads
            can remove them.
            If the queue is empty the thread reading messages is blocked until a message
            is put to the queue or the thread is unblocked.
            </remarks>
            <typeparam name="TMessage">Type of the message.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.EnqueueMessage(`0)">
            <summary>
            Puts message to the queue.
            </summary>
            <param name="message">message that shall be enqueued</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.DequeueMessage">
            <summary>
            Removes the first message from the queue. If the queue is empty the thread is blocked until a message is put to the queue.
            To unblock waiting threads, use UnblockProcesseingThreads().
            </summary>
            <returns>message, it returns null if the waiting thread was unblocked but there is no message in the queue.</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.PeekMessage">
            <summary>
            Reads the first message from the queue. If the queue is empty the thread is blocked until a message is put to the queue.
            To unblock waiting threads, use UnblockProcesseingThreads().
            </summary>
            <returns>
            message, it returns null if the waiting thread was unblocked but there is no message in the queue.
            </returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.DequeueMessage(System.Int32)">
            <summary>
            Removes the first message from the queue. If the queue is empty the thread is blocked until the specified timeout.
            The method UnblockProcesseingThreads() unblocks threads waiting in this method.
            </summary>
            <param name="millisecondsTimeout">Maximum waiting time for the message. If the time is exceeded the TimeoutException is thrown.</param>
            <returns>message</returns>
            <exception cref="T:System.TimeoutException">when the specified timeout is exceeded</exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.PeekMessage(System.Int32)">
            <summary>
            Reads the first message from the queue. If the queue is empty the thread is blocked until a message is put to the queue.
            To unblock waiting threads, use UnblockProcesseingThreads().
            </summary>
            <param name="millisecondsTimeout">
            Maximum waiting time for the message. If the time is exceeded the TimeoutException is thrown.
            </param>
            <returns>message</returns>
            <exception cref="T:System.TimeoutException">when the specified timeout is exceeded</exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.Clear">
            <summary>
            Deletes all items from the message queue.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.UnblockProcessingThreads">
            <summary>
            Releases all threads waiting for messages in DequeueMessage() and sets the queue to the unblocking mode.
            </summary>
            <remarks>
            When the queue is in unblocking mode, the dequeue or peek will not block if data is not available but
            it will return null or default values.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.BlockProcessingThreads">
            <summary>
            Sets the queue to the blocking mode.
            </summary>
            <remarks>
            When the queue is in blocking mode, the dequeue and peek will block until data is available.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.WaitForQueueCall(System.Func{`0})">
            <summary>
            Waits until something is in the queue and then calls the specified delegate.
            If the waiting thread is released (by UnblockProcessingThreads) but the queue is still empty, it returns the default
            value of the specified template type.
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.myMessageQueue">
            <summary>
            Queue for messages.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.myIsBlockingMode">
            <summary>
            Indicates weather the reading from the queue blocks until data is available.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.IsBlockingMode">
            <summary>
            Returns true if the queue blocks threads during dequeue and peek.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.Count">
            <summary>
            Returns number of messages in the queue.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.DuplexRouterFactory">
            <summary>
            Implements the factory creating duplex router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.DuplexRouterFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the duplex router factory.
            </summary>
            <param name="duplexOutputChannelMessaging">
            the messaging system factory used to create duplex output channels
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.DuplexRouterFactory.CreateDuplexRouter">
            <summary>
            Creates the duplex router.
            </summary>
            <returns>duplex router</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.LoadBalancer.NamespaceDoc">
            <summary>
            Distributing the workload across a farm of receivers.
            </summary>
            <remarks>
            The load balancer maintains a list of receivers processing a certain request.
            When the balancer receives the request, it chooses which receiver shall process it,
            so that all receivers are loaded optimally.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.NamespaceDoc">
            <summary>
            Asynchronous communication using multiple threads.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ISyncDuplexTypedMessageSender`2">
            <summary>
            Synchronized sender of typed messages (it waits until the response is received).
            </summary>
            <remarks>
            Declares message sender that sends request messages of specified type and receive response messages of specified type.
            Synchronous means it when the message is sent it waits until the response message is received.
            If the waiting for the response message exceeds the specified timeout the TimeoutException is thrown.
            </remarks>
            <typeparam name="TResponse">Response message type.</typeparam>
            <typeparam name="TRequest">Request message type.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ISyncDuplexTypedMessageSender`2.SendRequestMessage(`1)">
            <summary>
            Sends the request message and returns the response.
            </summary>
            <remarks>
            It waits until the response message is received. If waiting for the response exceeds the specified timeout
            TimeoutException is thrown.
            </remarks>
            <param name="message">request message</param>
            <returns>response message</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.ISyncDuplexTypedMessageSender`2.ConnectionOpened">
            <summary>
            The event is raised when the connection with the receiver is open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.ISyncDuplexTypedMessageSender`2.ConnectionClosed">
            <summary>
            The event is raised when the connection with the receiver is closed.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener">
            <summary>
            WebSocket server.
            </summary>
            <remarks>
            <example>
            The following example implements a simple service echoing the incoming message back to the client.
            <code>
            using System;
            using Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem;
            
            namespace EchoService
            {
               class Program
               {
                   static void Main(string[] args)
                   {
                       WebSocketListener aService = new WebSocketListener(new Uri("ws://127.0.0.1:8045/Echo/"));
            
                       aService.StartListening(client =>
                       {
                           WebSocketMessage aMessage;
                           while ((aMessage = client.ReceiveMessage()) != null)
                           {
                               object aData;
                               if (aMessage.IsText)
                               {
                                   aData = aMessage.GetWholeTextMessage();
                               }
                               else
                               {
                                   aData = aMessage.GetWholeMessage();
                               }
            
                               // Send echo.
                               client.SendMessage(aData);
                           }
                       });
            
                       Console.WriteLine("WebSocket service is listening. Press Enter to stop.");
                       Console.ReadLine();
            
                       aService.StopListening();
                   }
               }
            }
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.#ctor(System.Uri)">
            <summary>
            Construct websocket service.
            </summary>
            <param name="webSocketUri">service address. Provide port number too.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.#ctor(System.Uri,Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ISecurityFactory)">
            <summary>
            Construct websocket service.
            </summary>
            <param name="webSocketUri">service address. Provide port number too.</param>
            <param name="securityFactory">
            Factory allowing SSL communication. <see cref="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.Security.ServerSslFactory"/>
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.StartListening(System.Action{Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.IWebSocketClientContext})">
            <summary>
            Starts listening.
            </summary>
            <remarks>
            To handle connected clients the connectionHandler delegate is called. The connectionHandler delegate
            is called in parallel from multiple threads as clients are connected.
            </remarks>
            <param name="connectionHandler">callback delegate handling incoming connections. It is called 
            from multiple threads.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.StopListening">
            <summary>
            Stops listening and closes all open connections with clients.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.IsListening">
            <summary>
            Returns true if the service is listening.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem.WebSocketListener.WebSocketListenerImpl">
            <summary>
            Wraps the the implementation of the path listener to a separate class because PathListenerProviderBase
            shall be visible only internally.
            In addition, the documentation needs to be generated for WebSocketListener - therefore all methods
            would have to be overriden to have its own specific help description.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Streaming.StreamUtil">
            <summary>
            Internal helper functionality for reading data from a stream.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory">
            <summary>
            Extension providing the communication via the message bus.
            </summary>
            <remarks>
            This messaging wraps the communication with the message bus.
            The duplex input channel created by this messaging will automatically connect the message bus and register the service
            when the startListening() is called.<br/>
            The duplex output channel created by this messaging will automatically connect the message bus and ask for the service
            when the openConnection() is called.<br/>
            <br/>
            The following example shows how to communicate via the message bus.
            
            <example>
            Implementation of the message bus service that will mediate the client-service communication:
            <code>
            class Program
                {
                    static void Main(string[] args)
                    {
                        // Message Bus will use TCP for the communication.
                        IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
                    
                        // Input channel to listen to services.
                        IDuplexInputChannel aServiceInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:8045/");
                    
                        // Input channel to listen to clients.
                        IDuplexInputChannel aClientInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:8046/");
                    
                        // Create the message bus.
                        IMessageBus aMessageBus = new MessageBusFactory().CreateMessageBus();
                    
                        // Attach channels to the message bus and start listening.
                        aMessageBus.AttachDuplexInputChannels(aServiceInputChannel, aClientInputChannel);
                    
                        Console.WriteLine("Message bus service is running. Press ENTER to stop.");
                        Console.ReadLine();
                    
                        // Detach channels and stop listening.
                        aMessageBus.DetachDuplexInputChannels();
                    }
                }
            </code>
            </example>
            
            <example>
            Implementation of the service which is exposed via the message bus:
            <code>
            public interface IEcho
            {
                string hello(string text);
            }
            
            ....
            
            internal class EchoService : IEcho
            {
                public string hello(string text)
                {
                    return text;
                }
            }
            
            ....
            
            class Program
            {
                static void Main(string[] args)
                {
                    // The service will communicate via Message Bus which is listening via TCP.
                    IMessagingSystemFactory aMessageBusUnderlyingMessaging = new TcpMessagingSystemFactory();
                    // note: only TCP/IP address which is exposed for services is needed.
                    IMessagingSystemFactory aMessaging = new MessageBusMessagingFactory("tcp://127.0.0.1:8045/", null, aMessageBusUnderlyingMessaging);
                
                    // Create input channel listening via the message bus.
                    // Note: this is address of the service inside the message bus.
                    IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("Eneter.Echo");
                
                    // Instantiate class implementing the service.
                    IEcho anEcho = new EchoService();
                
                    // Create the RPC service.
                    IRpcService&lt;IEcho&gt; anEchoService = new RpcFactory().CreateService&lt;IEcho&gt;(anEcho);
                
                    // Attach input channel to the service and start listening via the message bus.
                    anEchoService.AttachDuplexInputChannel(anInputChannel);
                
                    Console.WriteLine("Echo service is running. Press ENTER to stop.");
                    Console.ReadLine();
                
                    // Detach the input channel and stop listening.
                    anEchoService.DetachDuplexInputChannel();
                }
            }
            </code>
            </example>
            
            <example>
            Implementation of the client using the service which is exposed via the message bus:
            <code>
            class Program
            {
                static void Main(string[] args)
                {
                    // The client will communicate via Message Bus which is listening via TCP.
                    IMessagingSystemFactory aMessageBusUnderlyingMessaging = new TcpMessagingSystemFactory();
                    // note: only TCP/IP address which is exposed for clients is needed. 
                    IMessagingSystemFactory aMessaging = new MessageBusMessagingFactory(null, "tcp://127.0.0.1:8046/", aMessageBusUnderlyingMessaging);
                
                    // Create output channel that will connect the service via the message bus..
                    // Note: this is address of the service inside the message bus.
                    IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("Eneter.Echo");
                
                    // Create the RPC client for the Echo Service.
                    IRpcClient&lt;IEcho&gt; aClient = new RpcFactory().CreateClient&lt;IEcho&gt;();
                
                    // Attach the output channel and be able to communicate with the service via the message bus.
                    aClient.AttachDuplexOutputChannel(anOutputChannel);
                
                    // Get the service proxy and call the echo method.
                    IEcho aProxy = aClient.Proxy;
                    String aResponse = aProxy.hello("hello");
                
                    Console.WriteLine("Echo service returned: " + aResponse);
                    Console.WriteLine("Press ENTER to stop.");
                    Console.ReadLine();
                
                    // Detach the output channel.
                    aClient.DetachDuplexOutputChannel();
                }
            }
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.#ctor(System.String,System.String,Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="serviceConnctingAddress">message bus address for registered services.</param>
            <param name="clientConnectingAddress">message bus address for clients that want to connect a registered service.</param>
            <param name="underlyingMessaging">messaging system used by the message bus.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.#ctor(System.String,System.String,Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="serviceConnctingAddress">message bus address for registered services.</param>
            <param name="clientConnectingAddress">message bus address for clients that want to connect a registered service.</param>
            <param name="underlyingMessaging">messaging system used by the message bus.</param>
            <param name="protocolFormatter">protocol formatter used for the communication between channels.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates duplex output channel.
            </summary>
            <remarks>
            Channel id represents the logical address of the service inside the message bus. E.g. "Eneter.EchoService".
            </remarks>
            <param name="channelId">logical address of the service inside the message bus</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates duplex output channel.
            </summary>
            <remarks>
            Channel id represents the logical address of the service inside the message bus. E.g. "Eneter.EchoService".
            </remarks>
            <param name="channelId">logical address of the service inside the message bus</param>
            <param name="responseReceiverId">unique id representing the client</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates duplex input channel.
            </summary>
            <remarks>
            Channel id represents the logical address of the service inside the message bus. E.g. "Eneter.EchoService".
            </remarks>
            <param name="channelId">logical address of the service inside the message bus</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.InputChannelThreading">
            <summary>
            Provides thread dispatcher responsible for routing events from duplex input channel according to
            desired threading model.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed one by one via a working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MessageBus.MessageBusMessagingFactory.OutputChannelThreading">
            <summary>
            Provides thread dispatcher responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that received response messages are routed one by one via a working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.NamespaceDoc">
            <summary>
            Extension providing client authentication.
            </summary>
            <remarks>
            Provides extension to authenticate the connection.
            If the authentication passes the connection is established.
            If the authentication fails the connection is closed.
            <example>
            <ul>
            <li><see cref="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory"/> - client authenticated when connected</li>
            </ul>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.LoadBalancer.RoundRobinBalancerFactory">
            <summary>
            Implements factory to create the load balancer based on Round-Robin algorithm.
            </summary>
            <remarks>
            The Round-Robin balancer distributes the incoming requests equally to all maintained receivers.
            It means, the balancer maintains which receiver was used the last time. Then, when a new request comes,
            the balancer picks the next receiver in the list up. If it is at the end, then it starts from the beginning.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.RoundRobinBalancerFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="duplexOutputChannelsFactory">
            messaging system used to create duplex output channels that will be used for the communication with
            services from the farm.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.LoadBalancer.RoundRobinBalancerFactory.CreateLoadBalancer">
            <summary>
            Creates the load balancer using the Round-Robin algorithm.
            </summary>
            <returns>load balancer</returns>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.EneterTrace">
            <summary>
            Super duper trace.
            </summary>
            <remarks>
            <example>
            Example showing how to enable tracing of communication errors and warnings to a file:
            <code>
            EneterTrace.DetailLevel = EneterTrace.EDetailLevel.Short;
            EneterTrace.TraceLog = new StreamWriter("d:/tracefile.txt");
            </code>
            </example>
            <example>
            Example showing how to enable tracing of detailed communication sequence to a file:
            <code>
            EneterTrace.DetailLevel = EneterTrace.EDetailLevel.Debug;
            EneterTrace.TraceLog = new StreamWriter("d:/tracefile.txt");
            </code>
            </example>
            <br/>
            Notice: The trace does not display namespaces and method names in Compact Framework platform.
            <example>
            Example showing how you can trace entering/leaving methods:
            <code>
            private class MyClass
            {
                private void MyMethod()
                {
                    // Tracing entering and leaving the method.
                    // Note: The entering-leaving is traced only if detail level is 'Debug'.
                    using (EneterTrace.Entering())
                    {
                        ... method implementation ...
                        
                        // Tracing a warning message.
                        EneterTrace.Warning("This is a warning message.");
                        
                        ...
                    }
                }
            }
            
            The output:
            11:59:11.365 ~008 --> YourNameSpace.MyClass.MyMethod
            11:59:11.704 ~008  W: YourNameSpace.MyClass.MyMethod This is a warning message.
            11:59:12.371 ~008 &lt;--  YourNameSpace.MyClass.MyMethod [00:00:01 000ms 969.0us]
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Entering">
            <summary>
            Traces entering-leaving the method.
            </summary>
            <remarks>
            The enetering information for the method calling this constructor is put to the trace
            and the measuring of the time starts.
            In order to trace entering-leaving, the detail level must be set to 'Debug'.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.System#IDisposable#Dispose">
            <summary>
            Traces the leaving from the method including the duration time.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Info(System.String)">
            <summary>
            Traces the info message.
            </summary>
            <param name="message">info message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Info(System.String,System.String)">
            <summary>
            Traces the information message.
            </summary>
            <param name="message">info message</param>
            <param name="details">additional details</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Info(System.String,System.Exception)">
            <summary>
            Traces the info message.
            </summary>
            <param name="message">info message</param>
            <param name="err">exception that will be traced</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Warning(System.String)">
            <summary>
            Traces warning message.
            </summary>
            <param name="message">warning message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Warning(System.String,System.String)">
            <summary>
            Traces the warning message.
            </summary>
            <param name="message">warning message</param>
            <param name="details">additional details</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Warning(System.String,System.Exception)">
            <summary>
            Traces the warning message.
            </summary>
            <param name="message">warning message</param>
            <param name="err">exception that will be traced</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Error(System.String)">
            <summary>
            Traces the error message.
            </summary>
            <param name="message">error message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Error(System.String,System.String)">
            <summary>
            Traces the error message and details for the error.
            </summary>
            <param name="message">error message</param>
            <param name="errorDetails">error details</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Error(System.String,System.Exception)">
            <summary>
            Traces the error message.
            </summary>
            <param name="message">error message</param>
            <param name="err">exception that will be traced</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Debug(System.String)">
            <summary>
            Traces the debug message.
            </summary>
            <remarks>
            To trace debug messages, the detail level must be set to debug.
            </remarks>
            <param name="message">error message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.StartProfiler">
            <summary>
            Starts the profiler measurement.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.StopProfiler">
            <summary>
            Stops the profiler measurement and writes results to the trace.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.EnqueueJob(System.Action)">
            <summary>
            Enqueues a job to the queue.
            </summary>
            <remarks>
            The queueing of jobs ensures, the jobs are performed in the correct order
            and the writing of the processing does not consume the execution thread.
            </remarks>
            <param name="job"></param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.ProcessJobs(System.Object)">
            <summary>
            Removes traces from the queue and writes them.
            </summary>
            <remarks>
            The method is executed from a different thread.
            The thread then loops until the queue is processed.
            </remarks>
            <param name="x"></param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.#ctor">
            <summary>
            Private helper constructor.
            </summary>
            <remarks>
            The constructor is private, so the class can be enstantiating only via the 'Entering' method.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Diagnostic.EneterTrace.TraceLog">
            <summary>
            Sets or gets the user defined trace.
            </summary>
            <remarks>
            If the value is set, the trace messages are written to the specified trace and to the debug port.
            If the value is null, then messages are written only to the debug port.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Diagnostic.EneterTrace.DetailLevel">
            <summary>
            Sets or gets the detail level of the trace.
            </summary>
            <remarks>
            If the detail level is set to 'Short' then only info, warning and error messages are traced.<br/>
            If the detail level is set to 'Debug' then all messages are traced.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Diagnostic.EneterTrace.NameSpaceFilter">
            <summary>
            Sets or gets the regular expression that will be applied to the namespace to filter traced messages.
            </summary>
            <remarks>
            Sets or gets the regular expression that will be applied to the name space of the traced message.
            If the namespace matches with the regular expression, the message will be traced.
            If the filter is set to null, then the filter is not used and all messages will be traced.
            <example>
            The following example shows how to set the filter to trace a certain namespace.
            <code>
            // Set the debug detailed level.
            EneterTrace.DetailLevel = EneterTrace.EDetailLevel.Debug;
            
            // Examples:
            // Traces all name spaces starting with 'My.NameSpace'.
            EneterTrace.NameSpaceFilter = new Regex(@"^My\.NameSpace");
            
            // Traces exactly the name space 'My.NameSpace'.
            EneterTrace.NameSpaceFilter = new Regex(@"^My\.NameSpace$");
            
            // Traces name spaces starting with 'Calc.Methods' or 'App.Utilities'.
            EneterTrace.NameSpaceFilter = new Regex(@"^Calc\.Methods|^App\.Utilities");
            
            // Traces all name spaces except namespaces starting with 'Eneter'.
            EneterTrace.NameSpaceFilter = new Regex(@"^(?!\bEneter\b)");
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.EneterTrace.EDetailLevel">
            <summary>
            Detail level of the trace.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Diagnostic.EneterTrace.EDetailLevel.None">
            <summary>
            Messages are not traced.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Diagnostic.EneterTrace.EDetailLevel.Short">
            <summary>
            Info, Warning and Error messages.<br/>
            The debug messages and entering-leaving messages are not traced.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Diagnostic.EneterTrace.EDetailLevel.Debug">
            <summary>
            All messages are traced.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData">
            <summary>
            The data structure representing the wrapped data.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData.#ctor">
            <summary>
            Default constructor used for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData.#ctor(System.Object,System.Object)">
            <summary>
            Constructs wrapped data from input parameters.
            </summary>
            <param name="addedData">new data added to the original data</param>
            <param name="originalData">original data</param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData.AddedData">
            <summary>
            Newly added data.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData.OriginalData">
            <summary>
            Original (wrapped) data.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory">
            <summary>
            Creates output and input channels which use TCP.
            </summary>
            <remarks>
            It creates the communication channels using TCP for sending and receiving messages.
            The channel id must be a valid URI address. E.g.: tcp://127.0.0.1:6080/. <br/>
            Notice, Silverlight and Windows Phone do not support TCP listeners.
            Therefore, only sending of messages (and receiving response messages) is possible on these platforms.<br/>
            More details:<br/>
            TCP in Silverlight is restricted to ports 4502 - 4532 and requires the TcpPolicyServer running on the service side.<br/>
            Windows Phone 7.0 does not suport TCP at all. The TCP is supported from Windows Phone 7.1. TCP in Windows Phone 7.1
            does not require TcpPolicyServer and is not restricted to certain ports as in Silverlight. 
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.#ctor">
            <summary>
            Constructs the TCP messaging factory.
            </summary>
            <remarks>
            The connection and sending timeouts are sent to 30 seconds. All incoming messages will notified via one working thread.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter{System.Byte[]})">
            <summary>
            Constructs the TCP messaging factory.
            </summary>
            <param name="protocolFormatter">formats OpenConnection, CloseConnection and Message messages between channels.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using TCP.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            <example>
            Creating the duplex output channel.
            <code>
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:8765/");
            </code>
            </example>
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid URI address e.g. tcp://127.0.0.1:8090/ </param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using TCP.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            <example>
            Creating the duplex output channel with specified client id.
            <code>
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:8765/", "MyUniqueClientId_1");
            </code>
            </example>
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid URI address e.g. tcp://127.0.0.1:8090/ </param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using TCP.
            The method is not supported in Silverlight and Windows Phone.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            <example>
            Creating duplex input channel.
            <code>
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:9876/");
            </code>
            </example>
            </remarks>
            <param name="channelId">Identifies this duplex input channel. The channel id must be a valid URI address (e.g. tcp://127.0.0.1:8090/) the input channel will listen to.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.ServerSecurityStreamFactory">
            <summary>
            Sets or gets the security stream factory for the server.
            If the factory is set, then the input channel and the duplex input channel use it to establish
            the secure communication.
            </summary>
            <remarks>
            If set to null then default NonSecurityFactory is created and used.
            <example>
            Using SSL on the service side.
            <code>
            TcpMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            aMessaging.ServerSecurityStreamFactory = new ServerSslFactory(serverX509Certificate);
            
            // Create input channel using SSL.
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:9876/");
            </code>
            </example>
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.ClientSecurityStreamFactory">
            <summary>
            Sets and gets the security stream factory for the client.
            If the factory is set, then the output channel and the duplex output channel use it to establish
            the secure communication.
            </summary>
            <remarks>
            If set to null then default NonSecurityFactory is created and used.
            <example>
            Using SSL on the client side.
            <code>
            TcpMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            aMessaging.ClientSecurityStreamFactory = new ClientSslFactory(hostNamePresentOnServiceCertificate);
            
            // Create input channel using SSL.
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:9876/");
            </code>
            </example>
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.SendBufferSize">
            <summary>
            Size of the buffer in bytes for sending messages. Default value is 8192 bytes.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.ReceiveBufferSize">
            <summary>
            Size of the buffer in bytes for receiving messages. Default value is 8192 bytes.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.SendTimeout">
            <summary>
            Sets or gets timeout to send a message. Default is 0 what it infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.ReceiveTimeout">
            <summary>
            Sets or gets timeout to receive a message. If not received within the time the connection is closed. Default is 0 what it infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.ConnectTimeout">
            <summary>
            Sets ot gets timeout to open the connection. Default is 30000 miliseconds. Value 0 is infinite time.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.InputChannelThreading">
            <summary>
            Provides thread dispatcher responsible for routing events from duplex input channel according to
            desired threading model.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed one by one via a working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Provides thread dispatcher responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that received response messages are routed one by one via a working thread.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.DefaultDuplexInputChannel.CreateResponseMessageSender(Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.MessageContext,System.String)">
            <summary>
            Creates the connection if does not exist.
            Returns false if the opening the connection was not approved - user rejected the connection via the connection token.
            </summary>
            <param name="messageContext"></param>
            <param name="responseReceiverId"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.ListeningInstance.StartListening(System.Action{System.IO.Stream})">
            <summary>
            Starts the thread where the instance loops trying to serve client requests.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.ListeningInstance.SetStopListeningFlag">
            <summary>
            Sets the stop listening flag before call StopListening().
            The problem is that the StopListening() stops some listening instance - not neccessarily this one.
            Therefore, we let know to all of them that the sop will come.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.ListeningInstance.StopListening(System.String,System.Collections.Generic.List{Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.ListeningInstance})">
            <summary>
            Stops listening of one instance listening to this pipe.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.NamedPipeMessagingSystem.ListeningInstance.DoListening">
            <summary>
            Listens to client requests and put them to the queue from where the working thread takes them
            and notifies the call-backs the pipe input channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer">
            <summary>
            HTTP policy server needed for the communication with Silverlight applications.
            </summary>
            <remarks>
            The policy server is required by Silverlight for the communication via HTTP or TCP.
            (See also <see cref="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpPolicyServer"/>.)
            Windows Phone 7 (based on Silverlight 3 too) does not require the policy server.
            <br/><br/>
            The HTTP policy server is a special service listening to the HTTP root address. When it receives the
            request with the path '/clientaccesspolicy.xml', it returns the content of the policy file.
            <br/><br/>
            Silverlight automatically uses this service before an HTTP request is invoked.
            If the Silverlight application invokes the HTTP request (e.g. http://127.0.0.1/MyService/),
            Silverlight first sends the request on the root (i.e. http://127.0.0.1/) and expects the policy file.
            If the policy server is not there or the content of the policy file does not allow the communication,
            the original HTTP request is not performed.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer.#ctor(System.String)">
            <summary>
            Constructs the Http policy server.
            </summary>
            <param name="httpRootAddress">
            root Http address. E.g. if the serivice has the address http://127.0.0.1/MyService/, the root
            address will be http://127.0.0.1/.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer.StartPolicyServer">
            <summary>
            Starts the policy server.
            </summary>
            <remarks>
            It starts the thread listening to HTTP requests and responding the policy file.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer.StopPolicyServer">
            <summary>
            Stops the policy server.
            </summary>
            <remarks>
            It stops the listening and responding for requests.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer.GetSilverlightDefaultPolicyXml">
            <summary>
            Returns the default xml policy file.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer.HttpRootAddress">
            <summary>
            Returns the root http address, that is served by the policy server.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer.PolicyXml">
            <summary>
            Gets or sets the policy xml.
            </summary>
            <remarks>
            When the class is instantiated, the default policy file is set.
            The default policy file allows to communicate with everybody.
            <br/>
            You can use this property to set your own policy file if needed.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpPolicyServer.IsListening">
            <summary>
            Returns true, if this instance of policy server is listening to requests.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Streaming.DynamicStream">
            <summary>
            Stream that can be written and read at the same time.
            </summary>
            <remarks>
            The dynamic stream supports writing of data by one thread and reading by another.
            The reading operation is blocked until the requested amount of data is not available.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Flush">
            <summary>
            The Flush is not applicable. If called, it does nothing.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            The stream does not support Seek.
            It throws NotSupportedException.
            </summary>
            <param name="offset">not applicable</param>
            <param name="origin">not applicable</param>
            <returns>not applicable</returns>
            <exception cref="T:System.NotSupportedException">
            </exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.SetLength(System.Int64)">
            <summary>
            The stream does not support SetLength.
            It throws NotSupportedException.
            </summary>
            <param name="value">not applicable</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads data from the stream to the specified buffer.
            </summary>
            <remarks>
            If the requested amount of data is not available the thread is blocked until required amount of data
            is available - until data is written by another thread.
            </remarks>
            <param name="buffer">The buffer where the data will be written.</param>
            <param name="offset">Starting position in the buffer where data will be wqritten.</param>
            <param name="count">Requested amount of data to be read.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the data to the stream.
            </summary>
            <param name="buffer">Buffer to be written to the stream</param>
            <param name="offset">Starting podition in the buffer from where data will be read.</param>
            <param name="count">Amount of data to be read from the buffer and written to the stream.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.WriteWithoutCopying(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes data to the stream the way that it just stores the reference to the input data.
            </summary>
            <remarks>
            It does not copyt the incoming data to the stream but instead of that it just stores the reference.
            This approach is very fast but the input byte[] array should not be modified after calling this method.
            </remarks>
            <param name="data">data to be written to the stream.</param>
            <param name="offset">Starting podition in the buffer from where data will be read.</param>
            <param name="count">Amount of data to be read from the buffer and written to the stream.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Close">
            <summary>
            Closes the stream and releases the reading thread waiting for data.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.myMessageQueue">
            <summary>
            The writing puts the byte sequences to the queue as they come.
            The reading removes the sequences of bytes from the queue.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.IsBlockingMode">
            <summary>
            Gets or sets the blocking mode. If blocking mode then Read method blocks until data is available.
            </summary>
            <remarks>
            If blocking mode then Read method blocks until data is available. If unblocking mode is set then
            Read method reads available data and returns. If a reading thread is blocked (waiting) and the unblocking mode
            is set the thread is released.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanRead">
            <summary>
            Returns true, because the stream supports reading.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanSeek">
            <summary>
            Returns false, because the stream does not support Seek.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanWrite">
            <summary>
            Returns true, because the stream supports writing.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Length">
            <summary>
            Returns always 0.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Position">
            <summary>
            'Get' returns always 0. Set does nothing.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.CryptoSerializerProvider.Serialize``1(``0,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Serializes data to the object.
            The returned object is type of byte[]. Output bytes are encrypted.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <param name="algorithm">algorithm used to encrypt the serialized data</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.CryptoSerializerProvider.Deserialize``1(System.Object,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Encrypted data to be deserialized.</param>
            <param name="algorithm">algorithm used to decrypt data before deserialization</param>
            <returns>Deserialized object.</returns>
        </member>
    </members>
</doc>
